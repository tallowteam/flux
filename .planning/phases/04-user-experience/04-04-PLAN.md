---
phase: 04-user-experience
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - src/queue/history.rs
  - src/queue/mod.rs
  - src/cli/args.rs
  - src/main.rs
  - src/transfer/mod.rs
  - tests/phase4_integration.rs
autonomous: true
requirements:
  - PATH-04
  - QUEUE-05
  - CLI-05

must_haves:
  truths:
    - "User can view transfer history with `flux history` showing timestamps, source, dest, size, speed"
    - "Completed transfers are automatically recorded in history"
    - "User can generate shell completions with `flux completions bash` (also zsh, fish, powershell)"
    - "History entries are capped at configurable limit (default 1000)"
    - "History persists across CLI invocations in history.json"
  artifacts:
    - path: "src/queue/history.rs"
      provides: "HistoryEntry, HistoryStore with append and list"
      exports: ["HistoryEntry", "HistoryStore"]
    - path: "src/cli/args.rs"
      provides: "History and Completions subcommands"
      contains: "Commands::History"
    - path: "tests/phase4_integration.rs"
      provides: "Integration tests for Phase 4 features"
  key_links:
    - from: "src/transfer/mod.rs"
      to: "src/queue/history.rs"
      via: "HistoryStore::append() called after successful transfer"
      pattern: "HistoryStore.*append"
    - from: "src/main.rs"
      to: "src/queue/history.rs"
      via: "HistoryStore::load() for history command"
      pattern: "HistoryStore::load"
    - from: "src/cli/args.rs"
      to: "clap_complete"
      via: "Shell value-enum in CompletionsArgs"
      pattern: "clap_complete::Shell"
---

<objective>
Implement transfer history recording, the history CLI command, shell completion generation, and integration tests for all Phase 4 features.

Purpose: Complete the user experience loop: users can review past transfers, shell completions make the CLI discoverable, and integration tests verify all Phase 4 features work end-to-end.
Output: Working `flux history`, `flux completions <shell>`, history recording in transfer pipeline, and comprehensive integration tests.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-experience/04-RESEARCH.md
@.planning/phases/04-user-experience/04-01-SUMMARY.md
@.planning/phases/04-user-experience/04-02-SUMMARY.md
@.planning/phases/04-user-experience/04-03-SUMMARY.md

Key existing files:
@src/cli/args.rs (updated in Plans 01-03)
@src/main.rs (updated in Plans 01-03)
@src/queue/mod.rs (from Plan 03)
@src/queue/state.rs (from Plan 03)
@src/config/paths.rs (from Plan 01)
@src/config/types.rs (from Plan 02)
@src/transfer/mod.rs (from Plan 02)
@Cargo.toml (clap_complete already added in Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: History store, history CLI, and transfer recording</name>
  <files>
    src/queue/history.rs
    src/queue/mod.rs
    src/cli/args.rs
    src/main.rs
    src/transfer/mod.rs
  </files>
  <action>
1. Create `src/queue/history.rs`:
   ```rust
   use chrono::{DateTime, Utc};
   use serde::{Deserialize, Serialize};
   use std::path::{Path, PathBuf};
   use crate::error::FluxError;

   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct HistoryEntry {
       pub source: String,
       pub dest: String,
       pub bytes: u64,
       pub files: u64,
       pub duration_secs: f64,
       pub timestamp: DateTime<Utc>,
       pub status: String,  // "completed", "failed", "cancelled"
       pub error: Option<String>,
   }

   pub struct HistoryStore {
       path: PathBuf,
       entries: Vec<HistoryEntry>,
       limit: usize,
   }
   ```

   Methods:
   - `pub fn load(data_dir: &Path, limit: usize) -> Result<Self, FluxError>`: Load from `history.json`. If parse fails, warn and start fresh (don't block on corrupt history).
   - `pub fn append(&mut self, entry: HistoryEntry) -> Result<(), FluxError>`: Push entry, truncate oldest if over limit, save to disk.
   - `pub fn list(&self) -> &[HistoryEntry]`: Return all entries.
   - `fn save(&self) -> Result<(), FluxError>`: Write JSON to disk.

2. Update `src/queue/mod.rs` to export history:
   ```rust
   pub mod history;
   pub mod state;
   ```

3. Add History and Completions subcommands in `src/cli/args.rs`:
   ```rust
   /// View transfer history
   History(HistoryArgs),
   /// Generate shell completions
   Completions(CompletionsArgs),
   ```

   ```rust
   #[derive(clap::Args, Debug)]
   pub struct HistoryArgs {
       /// Maximum number of entries to show
       #[arg(short = 'n', long, default_value = "20")]
       pub count: usize,
       /// Clear all history
       #[arg(long)]
       pub clear: bool,
   }

   #[derive(clap::Args, Debug)]
   pub struct CompletionsArgs {
       /// Shell to generate completions for
       #[arg(value_enum)]
       pub shell: clap_complete::Shell,
   }
   ```

4. Add dispatch in `src/main.rs`:

   History command:
   ```rust
   Commands::History(args) => {
       let data_dir = config::paths::flux_data_dir()?;
       let config = config::types::load_config().unwrap_or_default();
       let mut store = queue::history::HistoryStore::load(&data_dir, config.history_limit)?;

       if args.clear {
           // Clear history by saving empty store
           store.clear();
           store.save()?;
           eprintln!("History cleared");
           return Ok(());
       }

       let entries = store.list();
       if entries.is_empty() {
           eprintln!("No transfer history");
           return Ok(());
       }

       // Show most recent N entries
       let start = if entries.len() > args.count { entries.len() - args.count } else { 0 };
       println!("{:<20} {:<8} {:<30} {:<30} {:<10}", "TIMESTAMP", "STATUS", "SOURCE", "DEST", "SIZE");
       println!("{}", "-".repeat(100));
       for entry in &entries[start..] {
           let ts = entry.timestamp.format("%Y-%m-%d %H:%M:%S").to_string();
           let size = format_bytes(entry.bytes);
           let speed = if entry.duration_secs > 0.0 {
               format_bytes((entry.bytes as f64 / entry.duration_secs) as u64) + "/s"
           } else {
               "N/A".to_string()
           };
           let source = truncate_str(&entry.source, 28);
           let dest = truncate_str(&entry.dest, 28);
           println!("{:<20} {:<8} {:<30} {:<30} {:<10}", ts, entry.status, source, dest, size);
       }
   }
   ```

   Add a simple `format_bytes(bytes: u64) -> String` helper that formats bytes as human-readable (e.g., "1.5 MB", "340 KB"). Use bytesize crate if available, or simple manual formatting.

   Completions command:
   ```rust
   Commands::Completions(args) => {
       use clap::CommandFactory;
       use clap_complete::generate;
       let mut cmd = Cli::command();
       generate(args.shell, &mut cmd, "flux", &mut std::io::stdout());
       Ok(())
   }
   ```

5. Record transfers in history. In `src/transfer/mod.rs`, at the end of `execute_copy` after a successful transfer:
   - Capture start time at the beginning of execute_copy using `std::time::Instant::now()`.
   - After successful copy (before returning Ok(())), record to history:
     ```rust
     // Record in history (best-effort, don't fail the transfer on history error)
     if let Ok(data_dir) = config::paths::flux_data_dir() {
         let config = config::types::load_config().unwrap_or_default();
         if let Ok(mut history) = queue::history::HistoryStore::load(&data_dir, config.history_limit) {
             let entry = queue::history::HistoryEntry {
                 source: source_str.clone(),
                 dest: dest_str.clone(),
                 bytes: /* total bytes from copy result */,
                 files: /* 1 for single file, files_copied for directory */,
                 duration_secs: start_time.elapsed().as_secs_f64(),
                 timestamp: chrono::Utc::now(),
                 status: "completed".to_string(),
                 error: None,
             };
             let _ = history.append(entry); // Ignore history write errors
         }
     }
     ```
   - Do NOT record dry-run operations in history.
   - Track bytes/files from the copy operation to fill in the entry correctly.

6. Add `clear()` method to HistoryStore that empties entries.

7. Unit tests in history.rs:
   - Append entries, verify list returns them
   - Append beyond limit, verify oldest truncated
   - Empty history returns empty slice
  </action>
  <verify>
`cargo build` succeeds. `cargo test queue::history` passes. Manual test: after `flux cp` succeeds, `flux history` shows the transfer. `flux completions bash` outputs valid bash completion script.
  </verify>
  <done>
HistoryStore records transfers with timestamps, sizes, durations. `flux history` displays recent transfers in formatted table. `flux completions <shell>` generates valid completion scripts. Transfers are automatically recorded in history on completion. History respects configurable limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for all Phase 4 features</name>
  <files>
    tests/phase4_integration.rs
  </files>
  <action>
1. Create `tests/phase4_integration.rs` with integration tests using `assert_cmd` and `tempfile`:

   Set up a custom config/data directory using env vars or by setting HOME/APPDATA for test isolation. If that's too complex, test the CLI output patterns instead.

   Tests to include:

   **Alias tests:**
   - `test_add_and_list_alias`: Run `flux add mynas /tmp/testshare`, then `flux alias`. Assert output contains "mynas" and "/tmp/testshare".
   - `test_remove_alias`: Add an alias, remove it with `flux alias rm mynas`, list and verify gone.
   - `test_alias_name_validation`: Run `flux add C /some/path` (single char), assert error about invalid name.
   - `test_alias_resolution_in_copy`: Add alias pointing to a temp dir, copy a file using `flux cp file.txt myalias:`, verify file appears in temp dir. (This requires creating the temp file and alias pointing to valid temp dir.)

   **Config/conflict tests:**
   - `test_dry_run_single_file`: Create temp source, run `flux cp source.txt dest.txt --dry-run`, verify no dest.txt created, output contains "[dry-run]".
   - `test_dry_run_directory`: Create temp dir with files, run `flux cp -r dir/ dest/ --dry-run`, verify dest/ not created.
   - `test_on_conflict_skip`: Create source and dest with same name, run `flux cp source.txt dest.txt --on-conflict skip`, verify dest unchanged.
   - `test_on_conflict_rename`: Create source and dest with same name, run `flux cp source.txt dest.txt --on-conflict rename`, verify both dest.txt and dest_1.txt exist.

   **Queue tests:**
   - `test_queue_add_and_list`: Run `flux queue add /tmp/a.txt /tmp/b.txt`, then `flux queue`, assert shows entry.
   - `test_queue_lifecycle`: Add, pause, resume, cancel -- verify status at each step via `flux queue`.
   - `test_queue_clear`: Add and cancel entry, run `flux queue clear`, verify empty.

   **History tests:**
   - `test_history_after_copy`: Copy a file, run `flux history`, verify entry appears with source/dest.
   - `test_history_clear`: Copy, then `flux history --clear`, then `flux history`, verify empty.

   **Completions tests:**
   - `test_completions_bash`: Run `flux completions bash`, assert output contains "flux" and "_flux" or "complete".
   - `test_completions_powershell`: Run `flux completions powershell`, assert non-empty output.

   Note: Some tests may need to control the config/data directory. Use environment variable overrides if the code supports it, or accept that tests use the real user config dir (less ideal but acceptable for CLI integration tests). If using real dirs, use unique alias/queue names to avoid conflicts.

   Alternatively, if test isolation is critical, add support for `FLUX_CONFIG_DIR` and `FLUX_DATA_DIR` env var overrides in `flux_config_dir()` and `flux_data_dir()`. This is a small, safe change to paths.rs:
   ```rust
   pub fn flux_config_dir() -> Result<PathBuf, FluxError> {
       if let Ok(override_dir) = std::env::var("FLUX_CONFIG_DIR") {
           let dir = PathBuf::from(override_dir);
           if !dir.exists() { std::fs::create_dir_all(&dir)?; }
           return Ok(dir);
       }
       // ... existing logic
   }
   ```
   Add this to both functions. This enables clean test isolation.
  </action>
  <verify>
`cargo test --test phase4_integration` passes all new integration tests. `cargo test` passes all tests (existing ~200 + new Phase 4 tests).
  </verify>
  <done>
Integration tests cover all Phase 4 features: aliases (add/list/remove/resolve), config (dry-run, conflict handling), queue (add/list/pause/resume/cancel/clear), history (recording/display/clear), and completions (bash, powershell). All tests pass alongside existing test suite.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo test` passes all tests (existing + Phase 4)
3. `flux history` shows past transfers with timestamps and sizes
4. `flux completions bash` outputs valid bash completion script
5. `flux completions powershell` outputs valid powershell completion script
6. After `flux cp`, history automatically records the transfer
7. `flux history --clear` clears all history
8. Integration tests pass in isolation (using FLUX_CONFIG_DIR/FLUX_DATA_DIR overrides)
</verification>

<success_criteria>
- Transfer history recorded automatically after each successful transfer
- History display includes timestamp, status, source, dest, size
- Shell completions generate valid scripts for all supported shells
- Integration tests verify all Phase 4 requirements end-to-end
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-experience/04-04-SUMMARY.md`
</output>
