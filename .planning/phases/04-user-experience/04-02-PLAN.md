---
phase: 04-user-experience
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/config/types.rs
  - src/transfer/conflict.rs
  - src/cli/args.rs
  - src/main.rs
  - src/transfer/mod.rs
autonomous: true
requirements:
  - CONF-01
  - CONF-02
  - CONF-03
  - CONF-05

must_haves:
  truths:
    - "User can configure conflict handling to overwrite/skip/rename/ask via config.toml or --on-conflict flag"
    - "User can configure failure handling to retry/pause/skip via config.toml or --on-error flag"
    - "User can configure retry count and exponential backoff in config.toml"
    - "User can preview operations with --dry-run showing what would happen without performing I/O"
    - "CLI flags override config.toml settings"
    - "Invalid config.toml does not block --help or non-transfer commands"
  artifacts:
    - path: "src/config/types.rs"
      provides: "FluxConfig with ConflictStrategy, FailureStrategy, retry settings, serde defaults"
      contains: "ConflictStrategy"
    - path: "src/transfer/conflict.rs"
      provides: "Conflict resolution logic and unique filename generation"
      exports: ["resolve_conflict", "find_unique_name"]
  key_links:
    - from: "src/transfer/mod.rs"
      to: "src/config/types.rs"
      via: "FluxConfig loaded and passed to execute_copy"
      pattern: "FluxConfig"
    - from: "src/transfer/mod.rs"
      to: "src/transfer/conflict.rs"
      via: "resolve_conflict() called before each file copy"
      pattern: "resolve_conflict"
    - from: "src/cli/args.rs"
      to: "src/config/types.rs"
      via: "CLI flag types match config enum types"
      pattern: "ConflictStrategy"
---

<objective>
Implement the configuration system with conflict/failure handling strategies, retry settings, and dry-run mode. Config is persisted in TOML with serde defaults, CLI flags override config values.

Purpose: Give users control over how transfers handle conflicts (existing files), failures (I/O errors), and enable safe previewing of operations before execution.
Output: Working config loading, --on-conflict/--on-error/--dry-run flags, conflict resolution in copy pipeline.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-experience/04-RESEARCH.md
@.planning/phases/04-user-experience/04-01-SUMMARY.md

Key existing files:
@src/config/types.rs
@src/config/paths.rs (from Plan 01)
@src/cli/args.rs
@src/main.rs
@src/transfer/mod.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand FluxConfig with strategies, retry settings, and config loading</name>
  <files>
    src/config/types.rs
    src/cli/args.rs
  </files>
  <action>
1. Rewrite `src/config/types.rs` to include full config system. Keep existing Verbosity enum and its impls. Add:

   ```rust
   #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, clap::ValueEnum)]
   #[serde(rename_all = "lowercase")]
   pub enum ConflictStrategy {
       Overwrite,
       Skip,
       Rename,
       Ask,
   }

   #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, clap::ValueEnum)]
   #[serde(rename_all = "lowercase")]
   pub enum FailureStrategy {
       Retry,
       Skip,
       Pause,
   }
   ```

   Derive `clap::ValueEnum` on both enums so they can be used directly as CLI argument types.

   Expand FluxConfig:
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   #[serde(default)]
   pub struct FluxConfig {
       pub verbosity: Verbosity,
       pub conflict: ConflictStrategy,
       pub failure: FailureStrategy,
       pub retry_count: u32,
       pub retry_backoff_ms: u64,
       pub default_destination: Option<String>,
       pub history_limit: usize,
   }
   ```
   Note: Verbosity needs Serialize/Deserialize derives added (with `#[serde(rename_all = "lowercase")]`).

   Implement `Default for FluxConfig`:
   - conflict: `ConflictStrategy::Ask`
   - failure: `FailureStrategy::Retry`
   - retry_count: 3
   - retry_backoff_ms: 1000
   - default_destination: None
   - history_limit: 1000
   - verbosity: `Verbosity::Normal`

   Add config load/save functions:
   ```rust
   pub fn load_config() -> Result<FluxConfig, FluxError> {
       let config_dir = crate::config::paths::flux_config_dir()?;
       let config_path = config_dir.join("config.toml");
       if config_path.exists() {
           let contents = std::fs::read_to_string(&config_path)?;
           let config: FluxConfig = toml::from_str(&contents)
               .map_err(|e| FluxError::Config(format!("Invalid config.toml: {}", e)))?;
           Ok(config)
       } else {
           Ok(FluxConfig::default())
       }
   }
   ```

   Config is NOT auto-created on first run (use in-memory defaults). Only written when user explicitly configures something.

2. Add CLI flags to CpArgs in `src/cli/args.rs`:
   ```rust
   /// Conflict handling: overwrite, skip, rename, ask
   #[arg(long, value_enum)]
   pub on_conflict: Option<ConflictStrategy>,

   /// Failure handling: retry, skip, pause
   #[arg(long, value_enum)]
   pub on_error: Option<FailureStrategy>,

   /// Preview operations without performing them
   #[arg(long)]
   pub dry_run: bool,
   ```

   Import ConflictStrategy and FailureStrategy from config::types.

3. Add unit tests for config loading:
   - Default config has expected values
   - TOML round-trip (serialize then deserialize) preserves values
   - Partial TOML (only some fields) fills in defaults for missing fields
  </action>
  <verify>
`cargo build` succeeds. `cargo test config::types` passes.
  </verify>
  <done>
FluxConfig has all strategy enums, retry settings, and serde defaults. CLI flags for --on-conflict, --on-error, --dry-run are parseable. Config loads from config.toml with graceful fallback to defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Conflict resolution logic, dry-run mode, and transfer integration</name>
  <files>
    src/transfer/conflict.rs
    src/transfer/mod.rs
    src/main.rs
  </files>
  <action>
1. Create `src/transfer/conflict.rs`:
   ```rust
   pub fn resolve_conflict(
       dest: &Path,
       strategy: ConflictStrategy,
   ) -> Result<Option<PathBuf>, FluxError>
   ```
   - If dest does not exist: return `Some(dest.to_path_buf())`.
   - `Overwrite`: return `Some(dest.to_path_buf())`.
   - `Skip`: print "Skipped (exists): {path}" to stderr, return `None`.
   - `Rename`: call `find_unique_name(dest)`, print rename message, return `Some(renamed)`.
   - `Ask`: check if stdin is a TTY (use `std::io::IsTerminal` trait on stdin -- available since Rust 1.70). If TTY, prompt user with "exists. (o)verwrite / (s)kip / (r)ename?". If not TTY, fall back to Skip.

   ```rust
   pub fn find_unique_name(path: &Path) -> PathBuf
   ```
   - Generate sequential names: `file_1.txt`, `file_2.txt`, etc. up to 9999.
   - Fallback: append Unix timestamp.

2. Update `src/transfer/mod.rs`:
   - Add `pub mod conflict;` to the module declarations at top.
   - Modify `execute_copy` signature or add a config parameter. The simplest approach: load config at the start of execute_copy and merge with CLI flags.
     ```rust
     // Load config (graceful -- use defaults on error)
     let config = config::types::load_config().unwrap_or_default();

     // CLI flags override config
     let conflict_strategy = args.on_conflict.unwrap_or(config.conflict);
     let failure_strategy = args.on_error.unwrap_or(config.failure);
     ```

   - **Dry-run mode**: After alias resolution, protocol detection, and source validation, if `args.dry_run` is true:
     - For single file: report `[dry-run] copy {source} -> {dest} ({size} bytes)`. If dest exists, report conflict action based on strategy.
     - For directory: walk the source tree (reuse existing walkdir logic), for each file report what would happen (copy/skip/overwrite/rename). Print summary at end: "Would copy N files (X bytes total)".
     - Return Ok(()) without performing any I/O.

   - **Conflict resolution in normal mode**: Before each file copy (both single-file and directory paths), call `resolve_conflict(dest, conflict_strategy)`. If returns None, skip the file. If returns Some(path), use that path as the actual destination.

   - **Failure handling**: In the directory copy loop, wrap per-file copy errors:
     - `FailureStrategy::Retry`: retry up to `config.retry_count` times with exponential backoff (`config.retry_backoff_ms * 2^attempt`). Use `std::thread::sleep`.
     - `FailureStrategy::Skip`: add error to TransferResult and continue (current behavior).
     - `FailureStrategy::Pause`: print error, prompt user "Press Enter to continue or Ctrl+C to abort", wait for input, then continue to next file.

3. Update main.rs dispatch for Cp command:
   - No major changes needed since config loading happens inside execute_copy. But ensure the quiet flag is still passed through.

4. Unit tests in conflict.rs:
   - `resolve_conflict` with non-existent dest returns Some(dest)
   - `resolve_conflict` with existing dest + Overwrite returns Some(dest)
   - `resolve_conflict` with existing dest + Skip returns None
   - `find_unique_name` generates sequential names
   - `find_unique_name` finds first available slot
  </action>
  <verify>
`cargo build` succeeds. `cargo test` passes all existing tests plus new conflict tests. Manual test: `flux cp file.txt dest.txt --dry-run` shows preview without copying. `flux cp file.txt dest.txt --on-conflict skip` skips if dest exists.
  </verify>
  <done>
Conflict resolution applies before every file copy with configurable strategy. Dry-run mode previews all operations without I/O. Failure handling supports retry with exponential backoff, skip, and pause. CLI flags override config.toml values. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo test` passes all tests (~200 existing + new)
3. `flux cp file.txt dest/ --dry-run` previews without copying
4. `flux cp file.txt dest/ --on-conflict skip` skips existing files
5. `flux cp file.txt dest/ --on-conflict rename` creates file_1.txt when dest exists
6. Config.toml with `conflict = "skip"` applies when no CLI flag given
7. Missing config.toml uses defaults without error
</verification>

<success_criteria>
- ConflictStrategy and FailureStrategy enums work as CLI value-enums and serde-serializable config values
- Config loads from TOML with serde defaults for missing fields
- Dry-run mode walks the full operation path without I/O
- Conflict resolution integrated into both single-file and directory copy paths
- Failure handling with retry/skip/pause in directory copy loop
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-experience/04-02-SUMMARY.md`
</output>
