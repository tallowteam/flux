---
phase: 04-user-experience
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/queue/mod.rs
  - src/queue/state.rs
  - src/cli/args.rs
  - src/main.rs
  - src/error.rs
autonomous: true
requirements:
  - QUEUE-01
  - QUEUE-02
  - QUEUE-03
  - QUEUE-04

must_haves:
  truths:
    - "User can queue a transfer with `flux queue add source dest`"
    - "User can view queue status with `flux queue` or `flux queue list`"
    - "User can pause a running transfer with `flux queue pause <id>`"
    - "User can resume a paused transfer with `flux queue resume <id>`"
    - "User can cancel a transfer with `flux queue cancel <id>`"
    - "User can process the queue with `flux queue run`"
    - "Queue state persists across CLI invocations in queue.json"
  artifacts:
    - path: "src/queue/state.rs"
      provides: "QueueEntry, QueueStatus, QueueStore with persistence"
      exports: ["QueueEntry", "QueueStatus", "QueueStore"]
    - path: "src/queue/mod.rs"
      provides: "Queue module exports"
      contains: "pub mod state"
    - path: "src/cli/args.rs"
      provides: "Queue subcommand with add/list/pause/resume/cancel/run actions"
      contains: "Commands::Queue"
  key_links:
    - from: "src/main.rs"
      to: "src/queue/state.rs"
      via: "QueueStore::load() and queue command dispatch"
      pattern: "QueueStore::load"
    - from: "src/queue/state.rs"
      to: "src/config/paths.rs"
      via: "flux_data_dir() for queue.json path"
      pattern: "flux_data_dir"
    - from: "src/queue/mod.rs"
      to: "src/transfer/mod.rs"
      via: "execute_copy() called during queue run"
      pattern: "execute_copy"
---

<objective>
Implement the transfer queue system: persistent queue state in JSON, CLI commands to add/list/pause/resume/cancel transfers, and a `queue run` command to process queued transfers.

Purpose: Enable users to batch multiple transfers and manage them as a queue, with control over individual transfer lifecycle (pause/resume/cancel), without requiring a background daemon.
Output: Working `flux queue` subcommand with all queue management operations, persisted in `queue.json`.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-experience/04-RESEARCH.md
@.planning/phases/04-user-experience/04-01-SUMMARY.md
@.planning/phases/04-user-experience/04-02-SUMMARY.md

Key existing files:
@src/cli/args.rs (updated in Plans 01-02)
@src/main.rs (updated in Plans 01-02)
@src/config/paths.rs (from Plan 01)
@src/config/types.rs (from Plan 02)
@src/transfer/mod.rs (from Plan 02)
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Queue state types and QueueStore with JSON persistence</name>
  <files>
    src/queue/state.rs
    src/queue/mod.rs
    src/error.rs
  </files>
  <action>
1. Create `src/queue/` directory and `src/queue/mod.rs`:
   ```rust
   pub mod state;
   ```

2. Register the queue module in `src/main.rs` (add `mod queue;`).

3. Create `src/queue/state.rs` with:

   ```rust
   use chrono::{DateTime, Utc};
   use serde::{Deserialize, Serialize};
   use std::path::{Path, PathBuf};
   use crate::error::FluxError;

   #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
   #[serde(rename_all = "lowercase")]
   pub enum QueueStatus {
       Pending,
       Running,
       Paused,
       Completed,
       Failed,
       Cancelled,
   }

   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct QueueEntry {
       pub id: u64,
       pub status: QueueStatus,
       pub source: String,
       pub dest: String,
       pub recursive: bool,
       pub verify: bool,
       pub compress: bool,
       pub added_at: DateTime<Utc>,
       pub started_at: Option<DateTime<Utc>>,
       pub completed_at: Option<DateTime<Utc>>,
       pub bytes_transferred: u64,
       pub error: Option<String>,
   }
   ```

   QueueStore struct:
   ```rust
   pub struct QueueStore {
       path: PathBuf,
       entries: Vec<QueueEntry>,
       next_id: u64,
   }
   ```

   Methods:
   - `pub fn load(data_dir: &Path) -> Result<Self, FluxError>`: Load from `queue.json`. If file exists, parse JSON. Compute next_id as max(id) + 1. If file doesn't exist, start empty with next_id=1. Handle parse errors gracefully (warn and start fresh if corrupted).
   - `pub fn save(&self) -> Result<(), FluxError>`: Atomic write via tmp file + rename (same pattern as AliasStore). Write `queue.json.tmp`, then rename to `queue.json`.
   - `pub fn add(&mut self, source: String, dest: String, recursive: bool, verify: bool, compress: bool) -> u64`: Create new entry with Pending status, current timestamp, return id.
   - `pub fn list(&self) -> &[QueueEntry]`: Return slice of all entries.
   - `pub fn get(&self, id: u64) -> Option<&QueueEntry>`: Find entry by id.
   - `pub fn get_mut(&mut self, id: u64) -> Option<&mut QueueEntry>`: Find mutable entry by id.
   - `pub fn pause(&mut self, id: u64) -> Result<(), FluxError>`: Set status to Paused if currently Pending or Running. Error if already completed/cancelled/failed.
   - `pub fn resume(&mut self, id: u64) -> Result<(), FluxError>`: Set status to Pending if currently Paused. Error otherwise.
   - `pub fn cancel(&mut self, id: u64) -> Result<(), FluxError>`: Set status to Cancelled. Set completed_at to now. Error if already completed.
   - `pub fn pending_entries(&self) -> Vec<&QueueEntry>`: Return entries with Pending status, ordered by id.
   - `pub fn clear_completed(&mut self)`: Remove all Completed, Failed, and Cancelled entries.

4. Add `QueueError` variant to FluxError in `src/error.rs`:
   ```rust
   #[error("Queue error: {0}")]
   QueueError(String),
   ```
   With suggestion: "Check queue status with `flux queue`."

5. Unit tests for QueueStore:
   - Add entry, verify id increments
   - Pause/resume state transitions
   - Cancel sets completed_at
   - Invalid state transitions return errors (e.g., pause a completed entry)
   - Serialize/deserialize round-trip
  </action>
  <verify>
`cargo build` succeeds. `cargo test queue::state` passes all unit tests.
  </verify>
  <done>
QueueStore manages queue entries with proper state transitions. JSON persistence uses atomic writes. All state transitions validated (can't pause completed, can't resume running, etc.). Round-trip serialization works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Queue CLI subcommands and queue run execution</name>
  <files>
    src/cli/args.rs
    src/main.rs
  </files>
  <action>
1. Add Queue subcommand to Commands enum in `src/cli/args.rs`:
   ```rust
   /// Manage transfer queue
   Queue(QueueArgs),
   ```

   ```rust
   #[derive(clap::Args, Debug)]
   pub struct QueueArgs {
       #[command(subcommand)]
       pub action: Option<QueueAction>,
   }

   #[derive(Subcommand, Debug)]
   pub enum QueueAction {
       /// Add a transfer to the queue
       Add(QueueAddArgs),
       /// List queued transfers
       List,
       /// Pause a queued transfer
       Pause(QueueIdArgs),
       /// Resume a paused transfer
       Resume(QueueIdArgs),
       /// Cancel a queued transfer
       Cancel(QueueIdArgs),
       /// Process all pending transfers in the queue
       Run,
       /// Clear completed/failed/cancelled entries
       Clear,
   }

   #[derive(clap::Args, Debug)]
   pub struct QueueAddArgs {
       /// Source path or URI
       pub source: String,
       /// Destination path or URI
       pub dest: String,
       /// Copy directories recursively
       #[arg(short, long)]
       pub recursive: bool,
       /// Verify transfer integrity
       #[arg(long)]
       pub verify: bool,
       /// Enable compression
       #[arg(long)]
       pub compress: bool,
   }

   #[derive(clap::Args, Debug)]
   pub struct QueueIdArgs {
       /// Transfer ID
       pub id: u64,
   }
   ```

   When `QueueArgs.action` is None, default to listing (same as `flux queue list`).

2. Add queue command dispatch in `src/main.rs` run() function:
   ```rust
   Commands::Queue(args) => {
       let data_dir = config::paths::flux_data_dir()?;
       let mut store = queue::state::QueueStore::load(&data_dir)?;

       match args.action.unwrap_or(QueueAction::List) {
           QueueAction::Add(add_args) => {
               let id = store.add(
                   add_args.source,
                   add_args.dest,
                   add_args.recursive,
                   add_args.verify,
                   add_args.compress,
               );
               store.save()?;
               eprintln!("Queued transfer #{}", id);
           }
           QueueAction::List => {
               let entries = store.list();
               if entries.is_empty() {
                   eprintln!("Queue is empty");
               } else {
                   // Print formatted table to stdout
                   println!("{:<4} {:<10} {:<30} {:<30}", "ID", "STATUS", "SOURCE", "DEST");
                   println!("{}", "-".repeat(76));
                   for entry in entries {
                       let status = format!("{:?}", entry.status).to_lowercase();
                       let source = truncate_str(&entry.source, 28);
                       let dest = truncate_str(&entry.dest, 28);
                       println!("{:<4} {:<10} {:<30} {:<30}", entry.id, status, source, dest);
                   }
               }
           }
           QueueAction::Pause(id_args) => {
               store.pause(id_args.id)?;
               store.save()?;
               eprintln!("Paused transfer #{}", id_args.id);
           }
           QueueAction::Resume(id_args) => {
               store.resume(id_args.id)?;
               store.save()?;
               eprintln!("Resumed transfer #{}", id_args.id);
           }
           QueueAction::Cancel(id_args) => {
               store.cancel(id_args.id)?;
               store.save()?;
               eprintln!("Cancelled transfer #{}", id_args.id);
           }
           QueueAction::Run => {
               // Process pending entries sequentially
               let pending: Vec<u64> = store.pending_entries().iter().map(|e| e.id).collect();
               if pending.is_empty() {
                   eprintln!("No pending transfers in queue");
                   return Ok(());
               }
               eprintln!("Processing {} transfer(s)...", pending.len());

               for id in pending {
                   // Mark as running
                   if let Some(entry) = store.get_mut(id) {
                       entry.status = QueueStatus::Running;
                       entry.started_at = Some(chrono::Utc::now());
                   }
                   store.save()?;

                   // Get entry details for CpArgs construction
                   let entry = store.get(id).unwrap().clone();

                   // Check if paused/cancelled before executing
                   if entry.status != QueueStatus::Running {
                       continue;
                   }

                   eprintln!("\n[#{}] {} -> {}", id, entry.source, entry.dest);

                   // Build CpArgs from queue entry
                   let cp_args = CpArgs {
                       source: entry.source.clone(),
                       dest: entry.dest.clone(),  // or Some(entry.dest.clone()) if dest is Option
                       recursive: entry.recursive,
                       verify: entry.verify,
                       compress: entry.compress,
                       chunks: 0,
                       exclude: vec![],
                       include: vec![],
                       limit: None,
                       resume: false,
                       on_conflict: None,
                       on_error: None,
                       dry_run: false,
                   };

                   match transfer::execute_copy(cp_args, cli.quiet) {
                       Ok(()) => {
                           if let Some(e) = store.get_mut(id) {
                               e.status = QueueStatus::Completed;
                               e.completed_at = Some(chrono::Utc::now());
                           }
                           store.save()?;
                           eprintln!("[#{}] Completed", id);
                       }
                       Err(err) => {
                           if let Some(e) = store.get_mut(id) {
                               e.status = QueueStatus::Failed;
                               e.completed_at = Some(chrono::Utc::now());
                               e.error = Some(format!("{}", err));
                           }
                           store.save()?;
                           eprintln!("[#{}] Failed: {}", id, err);
                       }
                   }
               }
               eprintln!("\nQueue processing complete");
           }
           QueueAction::Clear => {
               store.clear_completed();
               store.save()?;
               eprintln!("Cleared completed/failed/cancelled entries");
           }
       }
       Ok(())
   }
   ```

   Add a helper function `truncate_str(s: &str, max: usize) -> String` that truncates long strings with "..." suffix for display formatting.

   Note: The `cli.quiet` reference in queue run -- either pass `quiet` flag through the run function, or access it from the Cli struct. Adjust the run() function signature if needed to pass quiet flag through.

3. Ensure `QueueAction` import is available. Add `use queue::state::QueueStatus;` and `use chrono;` to main.rs imports.
  </action>
  <verify>
`cargo build` succeeds. `cargo test` passes all tests. Manual test: `flux queue add /tmp/a.txt /tmp/b.txt && flux queue` shows queued transfer. `flux queue pause 1` pauses it. `flux queue resume 1` resumes. `flux queue cancel 1` cancels.
  </verify>
  <done>
`flux queue add` creates entries in queue.json. `flux queue` / `flux queue list` displays formatted table. Pause/resume/cancel change entry status correctly. `flux queue run` processes pending entries sequentially using execute_copy. `flux queue clear` removes finished entries. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo test` passes all tests
3. `flux queue add /tmp/src.txt /tmp/dst.txt` adds entry, shows "Queued transfer #1"
4. `flux queue` shows formatted table with ID, STATUS, SOURCE, DEST
5. `flux queue pause 1` / `flux queue resume 1` work correctly
6. `flux queue cancel 1` marks entry as cancelled
7. `flux queue run` processes pending transfers sequentially
8. Queue state persists across separate CLI invocations (data stored in queue.json)
9. `flux queue clear` removes completed/failed/cancelled entries
</verification>

<success_criteria>
- QueueStore persists entries in JSON with atomic writes
- State transitions are validated (can't pause completed, etc.)
- Queue run processes pending entries using existing execute_copy
- CLI provides full queue lifecycle management
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-experience/04-03-SUMMARY.md`
</output>
