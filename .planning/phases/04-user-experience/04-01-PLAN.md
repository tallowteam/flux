---
phase: 04-user-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/config/paths.rs
  - src/config/aliases.rs
  - src/config/mod.rs
  - src/cli/args.rs
  - src/main.rs
  - src/transfer/mod.rs
  - src/error.rs
autonomous: true
requirements:
  - PATH-01
  - PATH-02
  - PATH-03
  - PATH-05

must_haves:
  truths:
    - "User can save a named path alias with `flux add nas \\\\server\\share`"
    - "User can use alias in copy command with `flux cp file.txt nas:`"
    - "User can use alias with subpath `flux cp file.txt nas:docs/readme.md`"
    - "User can list saved aliases with `flux alias`"
    - "User can remove an alias with `flux alias rm nas`"
    - "User can set a default destination alias and use it when dest is omitted"
    - "Aliases do not collide with URL schemes (sftp:) or drive letters (C:)"
  artifacts:
    - path: "src/config/paths.rs"
      provides: "Platform-specific config/data directory helpers"
      exports: ["flux_config_dir", "flux_data_dir"]
    - path: "src/config/aliases.rs"
      provides: "AliasStore with CRUD operations and alias resolution"
      exports: ["AliasStore", "AliasFile", "resolve_alias"]
    - path: "src/cli/args.rs"
      provides: "Add, Alias subcommands in Commands enum"
      contains: "Commands::Add"
  key_links:
    - from: "src/transfer/mod.rs"
      to: "src/config/aliases.rs"
      via: "resolve_alias() called before detect_protocol()"
      pattern: "resolve_alias.*AliasStore"
    - from: "src/main.rs"
      to: "src/config/aliases.rs"
      via: "AliasStore::load() for Add/Alias commands"
      pattern: "AliasStore::load"
    - from: "src/config/aliases.rs"
      to: "src/config/paths.rs"
      via: "flux_config_dir() for aliases.toml path"
      pattern: "flux_config_dir"
---

<objective>
Implement the path alias system: persistent storage of named path aliases, CLI commands to manage them, and alias resolution integrated into the transfer pipeline before protocol detection.

Purpose: Enable users to save frequently-used paths (NAS shares, SFTP servers, WebDAV endpoints) as short aliases and use them in any flux command, eliminating repetitive long path entry.
Output: Working `flux add`, `flux alias`, and alias expansion in `flux cp` with aliases persisted in `aliases.toml`.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-user-experience/04-RESEARCH.md

Key existing files:
@src/cli/args.rs
@src/main.rs
@src/config/types.rs
@src/config/mod.rs
@src/transfer/mod.rs
@src/protocol/parser.rs
@src/error.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config directory helpers, AliasStore, and error types</name>
  <files>
    Cargo.toml
    src/config/paths.rs
    src/config/aliases.rs
    src/config/mod.rs
    src/error.rs
  </files>
  <action>
1. Add dependencies to Cargo.toml:
   - `clap_complete = "4.5"` (needed by Plan 04 but add now to avoid merge conflicts)
   - `chrono = { version = "0.4", features = ["serde"] }` (needed by Plan 03/04 but add now)

2. Create `src/config/paths.rs` with two functions:
   - `pub fn flux_config_dir() -> Result<PathBuf, FluxError>`: uses `dirs::config_dir()` to get platform-specific config dir, joins "flux", creates dir if not exists, returns path. Error if `config_dir()` returns None.
   - `pub fn flux_data_dir() -> Result<PathBuf, FluxError>`: uses `dirs::data_dir()`, joins "flux", creates dir if not exists. For data files (queue, history).
   - Both functions should use `FluxError::Config(...)` for errors.

3. Create `src/config/aliases.rs`:
   - `AliasFile` struct with `#[derive(Debug, Clone, Serialize, Deserialize, Default)]` containing `aliases: BTreeMap<String, String>` (use `#[serde(default)]`).
   - `AliasStore` struct with `path: PathBuf` and `data: AliasFile`.
   - Methods:
     - `pub fn load(config_dir: &Path) -> Result<Self, FluxError>`: load from `aliases.toml` in config_dir, or return default if file doesn't exist.
     - `pub fn save(&self) -> Result<(), FluxError>`: atomic write via tmp file + rename.
     - `pub fn add(&mut self, name: String, path: String)`: insert into BTreeMap.
     - `pub fn remove(&mut self, name: &str) -> bool`: remove from BTreeMap, return whether it existed.
     - `pub fn get(&self, name: &str) -> Option<&String>`: lookup by name.
     - `pub fn list(&self) -> &BTreeMap<String, String>`: return ref to all aliases.
   - `pub fn resolve_alias(input: &str, aliases: &AliasStore) -> String`: resolve `name:` or `name:subpath` patterns.
     - Find first colon. Extract candidate name (before colon).
     - SKIP if: name is empty, name length == 1 (drive letters), rest starts with "//" (URL schemes), name contains "/" or "\\".
     - If alias found: join base path with subpath using appropriate separator (backslash if base contains backslash, else forward slash). Empty subpath returns base path directly.
     - If not found: return input unchanged.
   - `pub fn validate_alias_name(name: &str) -> Result<(), FluxError>`: reject single chars, names starting with digit, names matching known schemes ("sftp", "ssh", "smb", "https", "http", "webdav", "dav", "ftp"), names with non-alphanumeric chars (allow hyphens and underscores). Return descriptive `FluxError::Config(...)` on rejection.
   - Unit tests: resolve_alias with valid alias, with subpath, with non-existent alias (passthrough), with URL scheme (passthrough), with drive letter (passthrough), with empty input, validate_alias_name happy/sad paths.

4. Update `src/config/mod.rs` to export new modules:
   ```rust
   pub mod aliases;
   pub mod paths;
   pub mod types;
   ```

5. Add `AliasError` variant to FluxError in `src/error.rs`:
   - `#[error("Alias error: {0}")]` `AliasError(String)` with suggestion "Check alias name with `flux alias`."
   - Add `impl From<toml::ser::Error>` for FluxError (serialization errors from alias save).
  </action>
  <verify>
`cargo build` succeeds. Unit tests in aliases.rs pass with `cargo test config::aliases`.
  </verify>
  <done>
`flux_config_dir()` and `flux_data_dir()` return correct platform paths and create directories. AliasStore can load/save/add/remove/get/list aliases from aliases.toml. resolve_alias correctly expands alias references while ignoring URL schemes and drive letters. validate_alias_name rejects invalid names.
  </done>
</task>

<task type="auto">
  <name>Task 2: Alias CLI subcommands and transfer integration</name>
  <files>
    src/cli/args.rs
    src/main.rs
    src/transfer/mod.rs
  </files>
  <action>
1. Extend `src/cli/args.rs` Commands enum with new subcommands:
   ```rust
   /// Save a path alias (e.g., flux add nas \\server\share)
   Add(AddArgs),
   /// Manage path aliases
   Alias(AliasArgs),
   ```
   - `AddArgs` struct: `pub name: String`, `pub path: String` (both positional).
   - `AliasArgs` struct with optional subcommand:
     ```rust
     #[derive(clap::Args, Debug)]
     pub struct AliasArgs {
         #[command(subcommand)]
         pub action: Option<AliasAction>,
     }

     #[derive(Subcommand, Debug)]
     pub enum AliasAction {
         /// Remove a saved alias
         Rm(AliasRmArgs),
     }

     #[derive(clap::Args, Debug)]
     pub struct AliasRmArgs {
         /// Name of alias to remove
         pub name: String,
     }
     ```
   - When `AliasArgs.action` is None, list all aliases (this is `flux alias` with no subcommand = list).

2. Update `src/main.rs` run() function to dispatch new commands:
   - `Commands::Add(args)`: Load AliasStore from `flux_config_dir()`, validate name with `validate_alias_name()`, call `store.add(name, path)`, call `store.save()`, print confirmation to stderr.
   - `Commands::Alias(args)`:
     - If `args.action` is None: Load AliasStore, iterate `store.list()`, print each alias as `name -> path` to stdout. Print "(no aliases saved)" if empty.
     - If `AliasAction::Rm(rm_args)`: Load AliasStore, call `store.remove(&rm_args.name)`. If returned false, print "Alias not found" to stderr. If true, save and print confirmation.

3. Integrate alias resolution into `src/transfer/mod.rs` execute_copy():
   - At the top of execute_copy, BEFORE detect_protocol() calls:
     ```rust
     // Resolve aliases before protocol detection
     let alias_store = match config::paths::flux_config_dir() {
         Ok(dir) => config::aliases::AliasStore::load(&dir).unwrap_or_default(),
         Err(_) => config::aliases::AliasStore::default(),
     };
     let source_str = config::aliases::resolve_alias(&args.source, &alias_store);
     let dest_str = config::aliases::resolve_alias(&args.dest, &alias_store);
     ```
   - Replace `args.source` with `source_str` and `args.dest` with `dest_str` in the detect_protocol() calls and subsequent code.
   - Add `AliasStore::default()` method that returns an empty store (no file path, empty BTreeMap) -- add this to aliases.rs if not already present. This is used when config dir is not available (graceful degradation).

4. Support default destination (PATH-03):
   - In execute_copy, check if `dest_str` is empty or equals "default:" after alias resolution. If so, look up the "default" alias. If found, use it. If not found, return `FluxError::Config("No default destination configured. Set with: flux add default <path>")`.
   - In CpArgs, make dest optional: `pub dest: Option<String>` with a default of None. When None, use "default:" as the dest_str trigger. NOTE: if changing dest to Option breaks too much, keep it as String but check for empty string.

5. Add integration tests at the bottom of transfer/mod.rs or as separate test:
   - Test that alias resolution + protocol detection work together (resolve "nas:" to a local path, detect as Local).
   - Test that unresolved aliases pass through unchanged (unknown alias name treated as literal path).
  </action>
  <verify>
`cargo build` succeeds. `cargo test` passes all existing tests plus new alias tests. Manual test: `flux add test-alias /tmp/test && flux alias` shows the alias. `flux alias rm test-alias` removes it.
  </verify>
  <done>
`flux add <name> <path>` saves an alias to aliases.toml. `flux alias` lists all aliases. `flux alias rm <name>` removes an alias. `flux cp file.txt name:` resolves the alias before protocol detection. Default destination works via the "default" alias. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors or warnings
2. `cargo test` passes all existing ~200 tests plus new alias unit tests
3. `flux add mytest /tmp/testdir` creates aliases.toml in config dir with the alias
4. `flux alias` lists saved aliases
5. `flux alias rm mytest` removes the alias
6. Alias resolution does not interfere with URL schemes: `sftp://host/path` still detected as SFTP
7. Alias resolution does not interfere with drive letters: `C:\path` still detected as Local
</verification>

<success_criteria>
- AliasStore persists aliases in TOML format in platform-specific config directory
- Alias resolution correctly expands `name:` and `name:subpath` patterns
- CLI commands Add/Alias work end-to-end
- No regressions in existing transfer tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-experience/04-01-SUMMARY.md`
</output>
