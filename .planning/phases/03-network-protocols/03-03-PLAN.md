---
phase: 03-network-protocols
plan: 03
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/backend/smb.rs
  - src/backend/mod.rs
  - Cargo.toml
  - tests/smb_backend.rs
autonomous: true
requirements:
  - PROT-02

must_haves:
  truths:
    - "SmbBackend implements FluxBackend trait with all 6 methods"
    - "On Windows, SMB uses native UNC paths via std::fs (with optional sambrs for authenticated shares)"
    - "On non-Windows, SMB uses pavao with libsmbclient bindings"
    - "Files can be read from and written to SMB shares through the FluxBackend interface"
    - "UNC paths like \\\\server\\share\\file are handled natively"
    - "SmbBackend reports supports_parallel: false and supports_seek: false"
    - "Backend factory creates SmbBackend when protocol is Smb"
  artifacts:
    - path: "src/backend/smb.rs"
      provides: "SmbBackend struct implementing FluxBackend, platform-conditional"
      min_lines: 80
      contains: "impl FluxBackend for SmbBackend"
    - path: "Cargo.toml"
      provides: "Platform-conditional SMB dependencies"
      contains: "sambrs"
  key_links:
    - from: "src/backend/smb.rs"
      to: "std::fs or pavao"
      via: "Platform-conditional file operations"
      pattern: "cfg(windows)|cfg(not(windows))"
    - from: "src/backend/mod.rs"
      to: "src/backend/smb.rs"
      via: "create_backend match arm for Protocol::Smb"
      pattern: "SmbBackend"
---

<objective>
Implement the SMB/CIFS backend so users can transfer files to/from network shares using `flux cp file.txt \\server\share\` or `flux cp file.txt smb://server/share/path`.

Purpose: SMB is the dominant file sharing protocol on Windows networks and is widely used in mixed environments. The implementation uses platform-conditional compilation: Windows leverages native OS support for UNC paths (the most natural and performant approach), while non-Windows platforms use the pavao crate wrapping libsmbclient.

Output: Working SmbBackend with platform-conditional implementation. Backend factory updated to create SmbBackend for SMB protocol.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-network-protocols/03-RESEARCH.md
@.planning/phases/03-network-protocols/03-01-SUMMARY.md
@src/backend/mod.rs
@src/backend/local.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement platform-conditional SmbBackend</name>
  <files>
    src/backend/smb.rs
    src/backend/mod.rs
    src/error.rs
    Cargo.toml
  </files>
  <action>
1. Update Cargo.toml:
   - Add Windows-only dependency: under `[target.'cfg(windows)'.dependencies]`, add `sambrs = "0.1"`.
   - Add non-Windows optional dependency: `pavao = { version = "0.2", features = ["vendored"], optional = true }`.
   - Add feature flag: `[features]` section with `smb = ["pavao"]` (on non-Windows, users opt in to avoid libsmbclient build cost). On Windows, SMB works without any feature flag since it uses std::fs + sambrs.

2. Create `src/backend/smb.rs` with platform-conditional implementations:

   **Windows implementation (`#[cfg(windows)]`):**

   ```rust
   pub struct SmbBackend {
       base_unc: PathBuf,  // e.g., \\server\share
       _connection: Option<sambrs::SmbShare>,  // kept alive for authenticated shares
   }
   ```

   `SmbBackend::connect(server, share, user, password)`:
   - Construct UNC path: `format!("\\\\{}\\{}", server, share)`
   - If user/password provided, use `sambrs::SmbShare::new(unc, user, password, None)` and call `.connect(false, false)?` to authenticate
   - If no credentials, just store the UNC path (Windows will use current user's session/cached credentials)
   - Return `SmbBackend { base_unc, _connection }`

   FluxBackend implementation — delegate to `std::fs` with UNC paths:
   - `stat()`: `std::fs::metadata(self.resolve(path))` -> convert to FileStat
   - `list_dir()`: `std::fs::read_dir(self.resolve(path))` -> map to FileEntry
   - `open_read()`: `std::fs::File::open(self.resolve(path))` -> Box::new(BufReader)
   - `open_write()`: `std::fs::File::create(self.resolve(path))` -> Box::new(BufWriter)
   - `create_dir_all()`: `std::fs::create_dir_all(self.resolve(path))`
   - `features()`: `BackendFeatures { supports_seek: false, supports_parallel: false, supports_permissions: false }`

   Helper `fn resolve(&self, path: &Path) -> PathBuf`: joins base_unc with the relative path.

   **Non-Windows implementation (`#[cfg(not(windows))]`):**

   Two cases: with `smb` feature (pavao available) or without.

   With pavao (`#[cfg(feature = "smb")]`):
   ```rust
   pub struct SmbBackend {
       client: pavao::SmbClient,
       base_path: String,
   }
   ```

   `SmbBackend::connect(server, share, user, password)`:
   - Create `SmbClient::new(SmbCredentials::default().server(&format!("smb://{}", server)).share(&format!("/{}", share)).username(user).password(password).workgroup("WORKGROUP"), SmbOptions::default())?`
   - Store client and base path

   FluxBackend implementation — CRITICAL: pavao's SmbFile is `!Send`, so read/write must buffer entirely in memory:
   - `open_read()`: Open file with `client.open_with(path, SmbOpenOptions::default().read(true))`, read ALL bytes into a `Vec<u8>`, return `Box::new(Cursor::new(bytes))`. This is the only way to return `Box<dyn Read + Send>` from a `!Send` SmbFile.
   - `open_write()`: Create a `SmbWriter` wrapper that buffers writes in a `Vec<u8>` and writes everything to the SMB share on `Drop` or explicit `flush`. Alternatively, return a channel-based writer that sends data to the SMB thread.
   - `stat()`: `client.stat(path)` -> convert to FileStat
   - `list_dir()`: `client.list_dir(path)` -> map entries to FileEntry
   - `create_dir_all()`: Split path, create each level with `client.mkdir(path, 0o755)`

   Without pavao (`#[cfg(not(feature = "smb"))]`):
   - `SmbBackend::connect()` returns `Err(FluxError::ProtocolError("SMB support requires the 'smb' feature flag. Rebuild with: cargo build --features smb".to_string()))`

3. Add `pub mod smb;` to `src/backend/mod.rs`.

4. Update `create_backend()` in `src/backend/mod.rs`:
   - Replace `Protocol::Smb` stub with real `SmbBackend::connect(server, share, user, password)?` call.
   - Extract credentials from Auth if present.
  </action>
  <verify>
Run `cargo build` on Windows — compiles with sambrs. Run `cargo test` — all existing tests pass. For non-Windows: `cargo build --features smb` compiles with pavao (if on Linux/macOS with build tools).
  </verify>
  <done>
SmbBackend compiles on Windows with native UNC path support via std::fs + sambrs. Non-Windows platforms have pavao-based implementation behind `smb` feature flag. Backend factory wired up. All FluxBackend methods implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SMB unit tests and integration test stubs</name>
  <files>
    tests/smb_backend.rs
    src/backend/smb.rs
  </files>
  <action>
1. Add unit tests in `src/backend/smb.rs` `#[cfg(test)] mod tests`:
   - Test `resolve()` helper correctly joins UNC base with relative path
   - Test `features()` returns correct BackendFeatures (supports_parallel: false, supports_seek: false)
   - Test path construction: `\\server\share` + `subdir\file.txt` = `\\server\share\subdir\file.txt`

2. Create `tests/smb_backend.rs` integration test:
   - Test that `flux cp localfile.txt \\\\server\\share\\dest.txt` attempts connection (validates protocol routing)
   - Test that `flux cp localfile.txt smb://server/share/dest.txt` also routes to SMB backend
   - Mark network-dependent tests with `#[ignore]`:
     ```rust
     #[test]
     #[ignore] // Requires SMB share: SMB_TEST_HOST, SMB_TEST_SHARE env vars
     fn smb_upload_download_roundtrip() {
         // Read env vars, upload temp file, download, compare
     }
     ```
   - On Windows, add a test that creates a local share (if possible) or at least tests UNC path resolution

3. Ensure all non-ignored tests pass with `cargo test`.
  </action>
  <verify>
Run `cargo test` — all tests pass. Run `cargo test smb` — SMB-specific non-ignored tests pass.
  </verify>
  <done>
SMB backend has unit tests for path resolution and features. Integration test stubs exist for manual testing. Protocol routing confirmed for both UNC and smb:// URL formats.
  </done>
</task>

</tasks>

<verification>
- `cargo build` succeeds on Windows (sambrs compiles)
- `cargo test` passes all existing + new non-ignored tests
- `SmbBackend` implements all 6 FluxBackend trait methods
- `create_backend(Protocol::Smb { ... })` returns Ok(Box<SmbBackend>)
- `flux cp file \\server\share\dest` routes through SMB backend
- `flux cp file smb://server/share/dest` routes through SMB backend
- BackendFeatures reports supports_parallel: false, supports_seek: false
</verification>

<success_criteria>
SMB backend is implemented with platform-conditional compilation. Windows uses native UNC paths via std::fs with sambrs for authenticated shares. Non-Windows uses pavao behind an opt-in feature flag. Users can transfer files to/from SMB shares using UNC paths or smb:// URLs.
</success_criteria>

<output>
After completion, create `.planning/phases/03-network-protocols/03-03-SUMMARY.md`
</output>
