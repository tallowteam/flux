---
phase: 03-network-protocols
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/args.rs
  - src/protocol/mod.rs
  - src/protocol/parser.rs
  - src/protocol/auth.rs
  - src/backend/mod.rs
  - src/transfer/mod.rs
  - src/main.rs
  - src/error.rs
  - Cargo.toml
  - tests/protocol_detection.rs
autonomous: true
requirements:
  - PROT-05

must_haves:
  truths:
    - "sftp://user@host/path is detected as SFTP protocol"
    - "\\\\server\\share\\path and //server/share/path are detected as SMB protocol"
    - "https://server/webdav/ and http://server/path are detected as WebDAV protocol"
    - "Regular file paths (relative and absolute) are detected as Local protocol"
    - "CpArgs accepts network URIs as source and destination strings without mangling"
    - "execute_copy resolves the correct backend from detected protocol before transfer"
  artifacts:
    - path: "src/protocol/mod.rs"
      provides: "Protocol enum, re-exports"
    - path: "src/protocol/parser.rs"
      provides: "detect_protocol() function, URL/UNC parsing"
      min_lines: 50
    - path: "src/protocol/auth.rs"
      provides: "Auth enum (None, Password, KeyFile, Agent)"
    - path: "src/backend/mod.rs"
      provides: "create_backend() factory function"
      contains: "create_backend"
    - path: "src/cli/args.rs"
      provides: "CpArgs with String source/dest instead of PathBuf"
      contains: "pub source: String"
  key_links:
    - from: "src/transfer/mod.rs"
      to: "src/protocol/parser.rs"
      via: "detect_protocol() call in execute_copy"
      pattern: "detect_protocol"
    - from: "src/transfer/mod.rs"
      to: "src/backend/mod.rs"
      via: "create_backend() call in execute_copy"
      pattern: "create_backend"
    - from: "src/protocol/parser.rs"
      to: "url crate"
      via: "Url::parse for scheme detection"
      pattern: "Url::parse"
---

<objective>
Create the protocol detection and backend factory infrastructure that all network backends depend on.

Purpose: This is the foundation for Phase 3. Before any network backend can work, the CLI must accept network URIs (not just PathBuf), the protocol parser must detect which protocol to use from the path format, and execute_copy must route through the correct backend.

Output: Protocol detection module, updated CLI args, backend factory, updated execute_copy dispatcher. All existing 124 tests continue to pass (local paths still work unchanged).
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-network-protocols/03-RESEARCH.md
@src/cli/args.rs
@src/backend/mod.rs
@src/transfer/mod.rs
@src/main.rs
@src/error.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protocol detection module and update CLI args</name>
  <files>
    src/protocol/mod.rs
    src/protocol/parser.rs
    src/protocol/auth.rs
    src/cli/args.rs
    src/main.rs
    src/error.rs
    Cargo.toml
  </files>
  <action>
1. Add `url = "2"` and `rpassword = "7"` to `[dependencies]` in Cargo.toml.

2. Create `src/protocol/mod.rs`:
   - Declare `pub mod parser;` and `pub mod auth;`
   - Define `Protocol` enum with variants:
     - `Local { path: PathBuf }`
     - `Sftp { user: String, host: String, port: u16, path: String }`
     - `Smb { server: String, share: String, path: String }`
     - `WebDav { url: String, auth: Option<Auth> }`
   - Re-export `detect_protocol` from parser and `Auth` from auth.

3. Create `src/protocol/auth.rs`:
   - Define `Auth` enum: `None`, `Password { user: String, password: String }`, `KeyFile { user: String, key_path: PathBuf, passphrase: Option<String> }`, `Agent { user: String }`
   - Derive Clone, Debug on Auth.

4. Create `src/protocol/parser.rs`:
   - `pub fn detect_protocol(input: &str) -> Protocol`
   - Detection order:
     a. Check for Windows UNC: starts with `\\` — parse `\\server\share\path` into `Protocol::Smb`
     b. Check for Unix UNC: starts with `//` but not `///` — parse `//server/share/path` into `Protocol::Smb`
     c. Try `url::Url::parse(input)`:
        - scheme `sftp` or `ssh` -> `Protocol::Sftp` with user from URL (default empty), host, port (default 22), path
        - scheme `smb` -> `Protocol::Smb` with server from host, share from first path segment, remaining path
        - scheme `https` or `http` or `webdav` or `dav` -> `Protocol::WebDav` with url=input, auth=None
     d. Fallback: `Protocol::Local { path: PathBuf::from(input) }`
   - Extract inline credentials from URL userinfo when present (user:password@host)
   - Handle edge cases: empty host, missing path, port normalization
   - Add unit tests for all protocol detection cases (at least 10 tests covering: local relative path, local absolute path, Windows UNC, Unix UNC, sftp:// with user, sftp:// without user, sftp:// with port, smb:// URL, https:// WebDAV, http:// WebDAV, dav:// WebDAV, local path that looks like but isn't a URL)

5. Change `CpArgs` in `src/cli/args.rs`:
   - Change `pub source: PathBuf` to `pub source: String`
   - Change `pub dest: PathBuf` to `pub dest: String`
   - This is necessary because PathBuf normalizes network URIs, destroying `sftp://` prefixes and UNC paths.

6. Add `mod protocol;` to `src/main.rs`.

7. Add `ProtocolError(String)` variant to `FluxError` in `src/error.rs` with message format `"Protocol error: {0}"` and a suggestion `"Check the URL format. Examples: sftp://user@host/path, \\\\server\\share, https://server/webdav/"`.
  </action>
  <verify>
Run `cargo test` — all existing tests pass (no regressions from String change). New protocol parser unit tests pass. Run `cargo build` — compiles cleanly.
  </verify>
  <done>
Protocol enum exists with Local/Sftp/Smb/WebDav variants. detect_protocol() correctly classifies all path formats. CpArgs uses String for source/dest. All 124+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backend factory and update execute_copy to use protocol routing</name>
  <files>
    src/backend/mod.rs
    src/transfer/mod.rs
    tests/protocol_detection.rs
  </files>
  <action>
1. Add `create_backend()` function to `src/backend/mod.rs`:
   ```rust
   pub fn create_backend(protocol: &Protocol) -> Result<Box<dyn FluxBackend>, FluxError> {
       match protocol {
           Protocol::Local { .. } => Ok(Box::new(local::LocalBackend::new())),
           Protocol::Sftp { .. } => Err(FluxError::ProtocolError(
               "SFTP backend not yet implemented".to_string()
           )),
           Protocol::Smb { .. } => Err(FluxError::ProtocolError(
               "SMB backend not yet implemented".to_string()
           )),
           Protocol::WebDav { .. } => Err(FluxError::ProtocolError(
               "WebDAV backend not yet implemented".to_string()
           )),
       }
   }
   ```
   Import Protocol from `crate::protocol`. The stub errors will be replaced by Plans 02-04.

2. Update `execute_copy()` in `src/transfer/mod.rs`:
   - At the top of execute_copy, parse source and dest through `detect_protocol()`:
     ```rust
     let src_protocol = detect_protocol(&args.source);
     let dst_protocol = detect_protocol(&args.dest);
     ```
   - Extract the local path from `Protocol::Local` for the existing logic (metadata checks, canonicalize, etc.)
   - For non-local protocols, call `create_backend()` to validate protocol is supported (will error with stub message for now)
   - Convert `source` and `dest` usage throughout execute_copy from `&PathBuf` to use the parsed protocol's path. For local protocol, extract the PathBuf from the enum.
   - Key changes in execute_copy:
     - `let source = &args.source;` becomes `let src_protocol = detect_protocol(&args.source);` and then extract path for local
     - All `std::fs::metadata(source)` calls work on the extracted local PathBuf
     - The function should validate that for non-local protocols, parallel chunked copy is skipped (force chunk_count=1)
   - Ensure all existing test assertions still work — the only difference is args.source/dest are now String but PathBuf::from(string) gives the same path.

3. Update any callers that construct CpArgs in tests — change PathBuf fields to String. Search for `CpArgs {` in test files and fix. Also update `src/main.rs` tracing debug format from `%args.source.display()` to just `%args.source` since source is now a String.

4. Create `tests/protocol_detection.rs` integration test:
   - Test that `flux cp localfile.txt localcopy.txt` still works (end-to-end with local paths as Strings)
   - Test that `flux cp file.txt sftp://user@host/path` returns a meaningful error ("SFTP backend not yet implemented")
   - Test that `flux cp file.txt \\\\server\\share\\dest` returns a meaningful error ("SMB backend not yet implemented")
   - Test that `flux cp file.txt https://server/webdav/` returns a meaningful error ("WebDAV backend not yet implemented")
  </action>
  <verify>
Run `cargo test` — all 124+ existing tests pass. New protocol_detection integration tests pass. `flux cp localfile localcopy` still works end-to-end. `flux cp file sftp://host/path` prints a clear "not yet implemented" error.
  </verify>
  <done>
Backend factory dispatches to LocalBackend for local paths and returns clear errors for unimplemented network protocols. execute_copy routes through protocol detection. All existing functionality preserved. Integration tests confirm both local (working) and network (stub error) paths.
  </done>
</task>

</tasks>

<verification>
- `cargo test` passes all 124+ existing tests (no regressions)
- `cargo test` passes new protocol parser unit tests (10+ cases)
- `cargo test --test protocol_detection` passes integration tests
- `flux cp localfile.txt dest.txt` works identically to before
- `flux cp file.txt sftp://user@host/path` returns ProtocolError
- `flux cp file.txt \\server\share\path` returns ProtocolError
- `flux cp file.txt https://server/webdav/` returns ProtocolError
</verification>

<success_criteria>
Protocol detection correctly identifies Local, SFTP, SMB, and WebDAV from path/URL format. CLI accepts arbitrary strings as source/dest. Backend factory routes to LocalBackend for local paths. execute_copy dispatches through protocol detection without breaking any existing functionality. Foundation is ready for Plans 02-04 to implement network backends.
</success_criteria>

<output>
After completion, create `.planning/phases/03-network-protocols/03-01-SUMMARY.md`
</output>
