---
phase: 03-network-protocols
plan: 04
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/backend/webdav.rs
  - src/backend/mod.rs
  - Cargo.toml
  - tests/webdav_backend.rs
autonomous: true
requirements:
  - PROT-04

must_haves:
  truths:
    - "WebDavBackend implements FluxBackend trait with all 6 methods"
    - "Async reqwest_dav operations bridged to sync via tokio Runtime::block_on"
    - "Files can be read from and written to WebDAV servers through the FluxBackend interface"
    - "WebDAV directory operations (list via PROPFIND, create via MKCOL) work"
    - "WebDavBackend reports supports_parallel: false and supports_seek: false"
    - "Backend factory creates WebDavBackend when protocol is WebDav"
    - "Basic auth credentials work when embedded in URL or provided separately"
  artifacts:
    - path: "src/backend/webdav.rs"
      provides: "WebDavBackend struct implementing FluxBackend with sync-over-async bridge"
      min_lines: 100
      contains: "impl FluxBackend for WebDavBackend"
    - path: "Cargo.toml"
      provides: "reqwest_dav and reqwest dependencies"
      contains: "reqwest_dav"
  key_links:
    - from: "src/backend/webdav.rs"
      to: "reqwest_dav crate"
      via: "Client::get, put, list, mkcol"
      pattern: "reqwest_dav::Client"
    - from: "src/backend/webdav.rs"
      to: "tokio runtime"
      via: "Runtime::block_on for sync-over-async bridging"
      pattern: "block_on"
    - from: "src/backend/mod.rs"
      to: "src/backend/webdav.rs"
      via: "create_backend match arm for Protocol::WebDav"
      pattern: "WebDavBackend::new"
---

<objective>
Implement the WebDAV backend so users can transfer files to/from WebDAV endpoints using `flux cp file.txt https://server/webdav/path`.

Purpose: WebDAV enables file transfer over HTTP/HTTPS, making it usable with many cloud storage services, NAS devices, and web servers that support WebDAV. The reqwest_dav crate is async, so this backend demonstrates the sync-over-async bridging pattern using a stored tokio Runtime.

Output: Working WebDavBackend that connects via HTTP/HTTPS, authenticates (Basic auth), bridges async operations to sync, and implements all FluxBackend methods. Backend factory updated for WebDAV protocol.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-network-protocols/03-RESEARCH.md
@.planning/phases/03-network-protocols/03-01-SUMMARY.md
@src/backend/mod.rs
@src/backend/local.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebDavBackend with sync-over-async bridge</name>
  <files>
    src/backend/webdav.rs
    src/backend/mod.rs
    Cargo.toml
  </files>
  <action>
1. Update Cargo.toml dependencies:
   - Add `reqwest_dav = "0.3"` (WebDAV client)
   - Add `reqwest = { version = "0.12", features = ["blocking"] }` (HTTP client, already a transitive dep of reqwest_dav but we need it explicit for Response type access)
   - Tokio is already in Cargo.toml with `features = ["full"]`

2. Create `src/backend/webdav.rs`:

   **WebDavBackend struct:**
   ```rust
   pub struct WebDavBackend {
       rt: tokio::runtime::Runtime,
       client: reqwest_dav::Client,
       base_url: String,
   }
   ```

   NOTE: tokio::runtime::Runtime is `!Send` by design, but we need `FluxBackend: Send + Sync`. Solution: wrap Runtime in an `Arc<Runtime>` or use a separate approach. Actually, `Runtime` IS `Send + Sync` as of tokio 1.x. Verify this in implementation. If not, use `Arc<Mutex<Runtime>>` or create a helper thread with a channel.

   **Constructor (`WebDavBackend::new`):**
   - Accept `url: &str` and `auth: Option<Auth>`
   - Create `tokio::runtime::Runtime::new()` (single-threaded is fine: `Builder::new_current_thread().enable_all().build()`)
   - Build `reqwest_dav::ClientBuilder::new().set_host(url.to_string())`
   - If auth is `Auth::Password { user, password }`, call `.set_auth(reqwest_dav::Auth::Basic(user, password))`
   - If URL contains userinfo (user:pass@host), extract and set Basic auth
   - Call `.build()` to create client
   - Return `WebDavBackend { rt, client, base_url: url.to_string() }`

   **FluxBackend implementation — all methods use `self.rt.block_on(async { ... })`:**

   `stat()`:
   ```rust
   self.rt.block_on(async {
       let path_str = path.to_str().unwrap_or("");
       let items = self.client.list(path_str, reqwest_dav::Depth::Number(0)).await?;
       // First item is the resource itself
       if let Some(item) = items.first() {
           Ok(FileStat {
               size: item.content_length.unwrap_or(0) as u64,
               is_dir: item.is_dir(), // or check content_type / resource_type
               is_file: !item.is_dir(),
               modified: item.last_modified, // Convert from DateTime if needed
               permissions: None,
           })
       } else {
           Err(FluxError::SourceNotFound { path: path.to_path_buf() })
       }
   })
   ```
   Map reqwest_dav errors to FluxError using a helper function.

   `list_dir()`:
   ```rust
   self.rt.block_on(async {
       let path_str = path.to_str().unwrap_or("");
       let items = self.client.list(path_str, reqwest_dav::Depth::Number(1)).await?;
       // Skip first item (self), map rest to FileEntry
       Ok(items.into_iter().skip(1).map(|item| FileEntry {
           path: PathBuf::from(&item.href),
           stat: FileStat { /* from item */ },
       }).collect())
   })
   ```

   `open_read()`:
   - Use `self.rt.block_on(async { self.client.get(path_str).await })`
   - Get response, then `self.rt.block_on(async { response.bytes().await })`
   - Return `Box::new(Cursor::new(bytes))` — buffers entire file in memory
   - Document limitation: files larger than available RAM will OOM. Future improvement: channel-based streaming or temp file.

   `open_write()`:
   - Return a `WebDavWriter` wrapper struct that:
     - Buffers all writes into an internal `Vec<u8>`
     - Holds a reference/clone of the client and runtime
     - On `flush()` or `Drop`, uploads the buffered data via `self.rt.block_on(async { self.client.put(path, data).await })`
   - WebDavWriter must implement `Write + Send`. Store the runtime as `Arc<Runtime>` and client data needed for upload.
   - Alternative simpler approach: Return a `Cursor<Vec<u8>>` from open_write and require callers to explicitly call a separate `upload()` method. BUT this breaks the FluxBackend trait contract. So the WebDavWriter approach is needed.

   Actually, the simplest correct approach for open_write:
   - Create a struct `WebDavWriter` with fields: `buffer: Vec<u8>`, `path: String`, `client: reqwest_dav::Client` (clone), `rt: Arc<tokio::runtime::Runtime>`, `flushed: bool`
   - Implement `Write` for WebDavWriter: `write()` appends to buffer, `flush()` does the actual PUT upload via block_on
   - Implement `Drop` for WebDavWriter: if not flushed, call flush (log error if it fails in Drop)
   - Make the Runtime an `Arc` in WebDavBackend so WebDavWriter can share it

   `create_dir_all()`:
   - Split path into components, create each via `self.rt.block_on(async { self.client.mkcol(path_str).await })`
   - Ignore "already exists" (405 Method Not Allowed or 301) errors

   `features()`: Return `BackendFeatures { supports_seek: false, supports_parallel: false, supports_permissions: false }`.

   **Error mapping:** Create `fn webdav_err(e: reqwest_dav::Error) -> FluxError` that converts to `FluxError::Io` or `FluxError::ProtocolError` depending on error type.

3. Add `pub mod webdav;` to `src/backend/mod.rs`.

4. Update `create_backend()` in `src/backend/mod.rs`:
   - Replace `Protocol::WebDav` stub with:
     ```rust
     Protocol::WebDav { url, auth } => {
         let backend = webdav::WebDavBackend::new(url, auth.clone())?;
         Ok(Box::new(backend))
     }
     ```
  </action>
  <verify>
Run `cargo build` — compiles with reqwest_dav. Run `cargo test` — all existing tests pass. Verify `WebDavBackend` implements `FluxBackend` (compiler will catch trait mismatches).
  </verify>
  <done>
WebDavBackend compiles, uses sync-over-async bridge with tokio Runtime, implements all 6 FluxBackend methods with reqwest_dav, handles Basic auth, and is wired into the backend factory. WebDavWriter properly buffers and uploads on flush.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WebDAV unit tests and integration test stubs</name>
  <files>
    tests/webdav_backend.rs
    src/backend/webdav.rs
  </files>
  <action>
1. Add unit tests in `src/backend/webdav.rs` `#[cfg(test)] mod tests`:
   - Test `features()` returns correct BackendFeatures (supports_parallel: false, supports_seek: false, supports_permissions: false)
   - Test `WebDavWriter` correctly buffers writes (write multiple chunks, verify internal buffer length)
   - Test error mapping from reqwest_dav errors to FluxError

2. Create `tests/webdav_backend.rs` integration test:
   - Test that `flux cp localfile.txt https://server/webdav/dest.txt` attempts connection (validates protocol routing end-to-end)
   - Test that `flux cp localfile.txt http://server/webdav/dest.txt` also routes to WebDAV
   - Test that `flux cp localfile.txt dav://server/path/` also routes to WebDAV
   - Mark all network-dependent tests with `#[ignore]`:
     ```rust
     #[test]
     #[ignore] // Requires WebDAV server: WEBDAV_TEST_URL env var
     fn webdav_upload_download_roundtrip() {
         // Read WEBDAV_TEST_URL env var
         // Upload temp file via flux cp, download via flux cp, compare
     }
     ```

3. Ensure all non-ignored tests pass with `cargo test`.
  </action>
  <verify>
Run `cargo test` — all tests pass. Run `cargo test webdav` — WebDAV-specific non-ignored tests pass. `cargo test -- --list` shows webdav test functions.
  </verify>
  <done>
WebDAV backend has unit tests for writer buffering and features. Integration test stubs exist for manual testing. Protocol routing confirmed for https://, http://, and dav:// URLs.
  </done>
</task>

</tasks>

<verification>
- `cargo build` succeeds (reqwest_dav compiles)
- `cargo test` passes all existing + new non-ignored tests
- `WebDavBackend` implements all 6 FluxBackend trait methods
- `create_backend(Protocol::WebDav { ... })` returns Ok(Box<WebDavBackend>)
- `flux cp file https://server/webdav/path` attempts real WebDAV connection
- WebDavWriter correctly buffers and uploads on flush
- BackendFeatures reports supports_parallel: false, supports_seek: false
</verification>

<success_criteria>
WebDAV backend is fully implemented with reqwest_dav, bridges async to sync via tokio Runtime, handles Basic auth, buffers file data for upload via WebDavWriter, and is wired into the backend factory. Users can attempt `flux cp file.txt https://server/webdav/path` and the tool will try to connect and transfer.
</success_criteria>

<output>
After completion, create `.planning/phases/03-network-protocols/03-04-SUMMARY.md`
</output>
