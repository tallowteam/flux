---
phase: 06-tui-mode
plan: 04
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - src/tui/components/queue_view.rs
  - src/tui/components/history_view.rs
  - src/tui/components/mod.rs
  - src/tui/app.rs
autonomous: true
requirements:
  - TUI-04
  - TUI-05

must_haves:
  truths:
    - "User can see queued transfers in a table with ID, status, source, dest"
    - "User can pause a selected transfer with 'p' key"
    - "User can resume a selected paused transfer with 'r' key"
    - "User can cancel a selected transfer with 'c' key"
    - "User can scroll through queue entries with j/k or arrow keys"
    - "User can see transfer history in a table with timestamp, status, source, dest, size"
    - "User can switch between Queue tab (3) and History tab (4) to see different views"
    - "Queue and history data reload from disk on tick to reflect external changes"
  artifacts:
    - path: "src/tui/components/queue_view.rs"
      provides: "QueueViewComponent with table rendering and pause/resume/cancel key bindings"
      contains: "QueueViewComponent"
      min_lines: 80
    - path: "src/tui/components/history_view.rs"
      provides: "HistoryViewComponent with table rendering of past transfers"
      contains: "HistoryViewComponent"
      min_lines: 60
  key_links:
    - from: "src/tui/components/queue_view.rs"
      to: "src/queue/state.rs"
      via: "Loads QueueStore, renders entries, mutates on pause/resume/cancel"
      pattern: "QueueStore"
    - from: "src/tui/components/history_view.rs"
      to: "src/queue/history.rs"
      via: "Loads HistoryStore, renders entries in table"
      pattern: "HistoryStore"
    - from: "src/tui/app.rs"
      to: "src/tui/components/queue_view.rs"
      via: "App delegates Queue tab to QueueViewComponent"
      pattern: "queue_view.*render|QueueViewComponent"
    - from: "src/tui/app.rs"
      to: "src/tui/components/history_view.rs"
      via: "App delegates History tab to HistoryViewComponent"
      pattern: "history_view.*render|HistoryViewComponent"
---

<objective>
Create Queue management and History view components, enabling users to manage transfers (pause/resume/cancel) and view transfer history from within the TUI.

Purpose: Completes the TUI's data views -- users can actively manage running/queued transfers and review past transfer history, all without leaving the TUI. This brings the CLI queue/history functionality into the interactive interface.

Output: Working QueueViewComponent and HistoryViewComponent integrated into the App's tab system.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tui-mode/06-RESEARCH.md
@.planning/phases/06-tui-mode/06-01-SUMMARY.md
@src/queue/state.rs
@src/queue/history.rs
@src/config/paths.rs
@src/config/types.rs
@src/tui/components/mod.rs
@src/tui/app.rs
@src/tui/action.rs
@src/tui/theme.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueueViewComponent with table and queue management key bindings</name>
  <files>
    src/tui/components/queue_view.rs
    src/tui/components/mod.rs
  </files>
  <action>
1. Create `src/tui/components/queue_view.rs`:

   **QueueViewComponent**:
   ```rust
   pub struct QueueViewComponent {
       entries: Vec<QueueEntry>,   // Cloned from QueueStore for rendering
       table_state: TableState,
       data_dir: Option<PathBuf>,  // Flux data dir for loading QueueStore
       status_message: Option<String>,  // Feedback after actions ("Paused #3", "Error: ...")
       message_ttl: u8,           // Ticks remaining before clearing status_message
   }
   ```

   **Constructor:**
   - `pub fn new() -> Self` -- try to load data_dir via `crate::config::paths::flux_data_dir()`, store as Option (None if unavailable). Load initial entries.

   **Data methods:**
   - `fn reload(&mut self)`:
     - If data_dir is Some, load `QueueStore::load(data_dir)` (ignore errors, keep stale data)
     - Clone entries list for rendering
   - `fn selected_id(&self) -> Option<u64>`:
     - Get selected index from table_state, look up entry ID
   - `fn perform_action(&mut self, action_fn: impl FnOnce(&mut QueueStore, u64) -> Result<(), FluxError>, verb: &str)`:
     - Helper that loads QueueStore, calls action_fn on selected ID, saves, sets status_message
     - On success: `"<Verb> #<id>"`, set message_ttl = 12 (3 seconds at 4Hz tick)
     - On error: `"Error: <msg>"`, set message_ttl = 20

   **Component trait implementation:**
   - `handle_key_event`:
     - `KeyCode::Up | KeyCode::Char('k')` -> select previous row
     - `KeyCode::Down | KeyCode::Char('j')` -> select next row
     - `KeyCode::Char('p')` -> pause selected entry:
       ```rust
       self.perform_action(|store, id| store.pause(id), "Paused");
       ```
     - `KeyCode::Char('r')` -> resume selected entry:
       ```rust
       self.perform_action(|store, id| store.resume(id), "Resumed");
       ```
     - `KeyCode::Char('c')` -> cancel selected entry:
       ```rust
       self.perform_action(|store, id| store.cancel(id), "Cancelled");
       ```
     - `KeyCode::Char('x')` -> clear completed/failed/cancelled:
       ```rust
       // Load QueueStore, call clear_completed(), save, reload
       ```
     - Return `Action::Noop` for all (state changes are internal)

   - `update`:
     - Reload queue data from disk
     - Decrement message_ttl, clear status_message when it hits 0

   - `render(frame, area)`:
     - Layout: vertical split:
       - Min(3): Queue table
       - Length(1): Status message line (if any)
     - **Queue Table**:
       - Columns: ID (6 wide), Status (12 wide), Source (35%), Dest (35%), Added (16 wide)
       - Header styled with `theme::HEADER`
       - Row styling based on status:
         - Pending: default
         - Running: green foreground
         - Paused: yellow foreground
         - Completed: dim/gray
         - Failed: red foreground
         - Cancelled: dim/gray
       - Selected row with `theme::SELECTED`
       - Block title: `"Queue ({N} entries)"` showing count
       - Render with `frame.render_stateful_widget(table, area, &mut self.table_state)`
     - **Status message** (if present):
       - Render as `Paragraph` in bottom row, styled based on content (green for success, red for error)
     - If entries are empty, show centered text: "Queue is empty" in dim style

2. In `src/tui/components/mod.rs`:
   - Add `pub mod queue_view;`
  </action>
  <verify>
    `cargo check` passes. Module compiles with all methods.
  </verify>
  <done>
    QueueViewComponent exists with table rendering of queue entries, keyboard navigation (j/k), and queue management actions (p=pause, r=resume, c=cancel, x=clear). Status feedback shown after actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HistoryViewComponent and integrate both views into App</name>
  <files>
    src/tui/components/history_view.rs
    src/tui/components/mod.rs
    src/tui/app.rs
  </files>
  <action>
1. Create `src/tui/components/history_view.rs`:

   **HistoryViewComponent**:
   ```rust
   pub struct HistoryViewComponent {
       entries: Vec<HistoryEntry>,  // Cloned from HistoryStore
       table_state: TableState,
       data_dir: Option<PathBuf>,
   }
   ```

   **Constructor:**
   - `pub fn new() -> Self` -- try to load data_dir, load initial history entries

   **Data methods:**
   - `fn reload(&mut self)`:
     - Load `HistoryStore::load(data_dir, 1000)` (default limit), clone entries
     - Reverse entries so most recent is first (HistoryStore stores oldest first)

   **Component trait implementation:**
   - `handle_key_event`:
     - `KeyCode::Up | KeyCode::Char('k')` -> select previous row
     - `KeyCode::Down | KeyCode::Char('j')` -> select next row
     - Default -> `Action::Noop`

   - `update`:
     - Reload history from disk

   - `render(frame, area)`:
     - **History Table**:
       - Columns: Timestamp (20 wide), Status (10 wide), Source (25%), Dest (25%), Size (10 wide), Duration (10 wide)
       - Header styled with `theme::HEADER`
       - Status color: "completed" = green, "failed" = red, other = default
       - Timestamp formatted as `YYYY-MM-DD HH:MM:SS`
       - Size formatted with `bytesize::ByteSize`
       - Duration formatted as `Xs` or `Xm Ys`
       - Selected row with `theme::SELECTED`
       - Block title: `"Transfer History ({N} entries)"`
       - Render with `frame.render_stateful_widget`
     - If entries are empty, show centered text: "No transfer history" in dim style

2. In `src/tui/components/mod.rs`:
   - Add `pub mod history_view;`

3. In `src/tui/app.rs`:
   - Add imports for `QueueViewComponent` and `HistoryViewComponent`
   - Add fields to App struct:
     ```rust
     queue_view: QueueViewComponent,
     history_view: HistoryViewComponent,
     ```
   - In `App::new()`:
     - Create `QueueViewComponent::new()` and `HistoryViewComponent::new()`
   - In `App::render()`:
     - When `active_tab` is `ActiveTab::Queue`: call `self.queue_view.render(frame, content_area)`
     - When `active_tab` is `ActiveTab::History`: call `self.history_view.render(frame, content_area)`
   - In `App::handle_key_event()`:
     - When `active_tab` is `ActiveTab::Queue`: delegate to `self.queue_view.handle_key_event(key)`
     - When `active_tab` is `ActiveTab::History`: delegate to `self.history_view.handle_key_event(key)`
   - In `App::on_tick()`:
     - Call `self.queue_view.update()` and `self.history_view.update()`
     - Note: Only update the active tab to avoid unnecessary disk I/O. Or update all -- disk reads are cheap for small JSON files.
   - Update status bar hints per tab:
     - Queue tab: `j/k:Navigate | p:Pause | r:Resume | c:Cancel | x:Clear | q:Quit`
     - History tab: `j/k:Navigate | q:Quit`
  </action>
  <verify>
    `cargo build` succeeds. Run `flux ui`:
    1. Press `3` for Queue tab -- shows queue entries (or "Queue is empty")
    2. If entries exist: j/k scrolls, p pauses, r resumes, c cancels (test by first adding entries with `flux queue add src dst`)
    3. Press `4` for History tab -- shows history entries (or "No transfer history")
    4. j/k scrolls through history entries
    5. Tab switching between all 4 tabs works
    6. `q` exits cleanly from any tab
  </verify>
  <done>
    Queue tab shows queue entries with pause/resume/cancel key bindings. History tab shows transfer history with scrollable table. Both integrated into App's tab system with appropriate status bar hints. Data reloads from disk on tick.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. Queue tab (press 3) shows queue entries in a table
3. Queue management works: p=pause, r=resume, c=cancel with status feedback
4. History tab (press 4) shows transfer history
5. Both tables support j/k scrolling with visible selection
6. Empty states show appropriate messages
7. Data refreshes periodically (external CLI changes reflected in TUI)
8. Status bar shows tab-appropriate key hints
9. All existing tests pass (`cargo test`)
</verification>

<success_criteria>
- QueueViewComponent renders queue entries and supports pause/resume/cancel actions
- HistoryViewComponent renders transfer history with timestamp, status, size, duration
- Both components reload data from disk on tick events
- Queue actions persist to disk (reflected in `flux queue` CLI)
- Tab system complete with all 4 views fully functional
- Status bar hints update per-tab
</success_criteria>

<output>
After completion, create `.planning/phases/06-tui-mode/06-04-SUMMARY.md`
</output>
