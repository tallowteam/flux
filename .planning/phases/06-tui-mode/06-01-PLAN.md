---
phase: 06-tui-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/cli/args.rs
  - src/main.rs
  - src/tui/mod.rs
  - src/tui/event.rs
  - src/tui/terminal.rs
  - src/tui/action.rs
  - src/tui/app.rs
  - src/tui/theme.rs
  - src/tui/components/mod.rs
  - src/tui/components/status_bar.rs
autonomous: true
requirements:
  - TUI-01
  - TUI-05
  - CLI-02

must_haves:
  truths:
    - "User can launch TUI with `flux ui` subcommand"
    - "User can launch TUI with `flux --tui` global flag"
    - "User can see tab bar with Dashboard, Files, Queue, History tabs"
    - "User can switch tabs with number keys (1-4) and Tab key"
    - "User can quit TUI with 'q' key"
    - "Terminal restores correctly on quit and on panic"
    - "`flux sync` command exists (skeleton returning 'not yet implemented')"
  artifacts:
    - path: "Cargo.toml"
      provides: "ratatui + crossterm dependencies"
      contains: "ratatui"
    - path: "src/tui/mod.rs"
      provides: "TUI module root with launch_tui() public API"
      exports: ["launch_tui"]
    - path: "src/tui/event.rs"
      provides: "Async EventHandler with tokio::select! multiplexing"
      contains: "EventHandler"
    - path: "src/tui/app.rs"
      provides: "App struct with ActiveTab enum and event dispatching"
      contains: "ActiveTab"
    - path: "src/tui/components/mod.rs"
      provides: "Component trait definition"
      contains: "trait Component"
    - path: "src/cli/args.rs"
      provides: "Ui subcommand and --tui flag and Sync skeleton"
      contains: "Ui"
  key_links:
    - from: "src/main.rs"
      to: "src/tui/mod.rs"
      via: "Commands::Ui and --tui flag route to tui::launch_tui()"
      pattern: "launch_tui"
    - from: "src/tui/app.rs"
      to: "src/tui/event.rs"
      via: "App main loop receives events from EventHandler"
      pattern: "events\\.next\\(\\)"
    - from: "src/tui/app.rs"
      to: "src/tui/components/mod.rs"
      via: "App dispatches to active Component"
      pattern: "Component"
---

<objective>
Create the TUI module foundation: async event loop, terminal management, Component trait architecture, App shell with tab switching, and CLI entry points (`flux ui`, `flux --tui`, `flux sync` skeleton).

Purpose: Establishes the TUI infrastructure that all subsequent view components (dashboard, file browser, queue, history) will plug into. This is the skeleton that makes the TUI launchable and navigable.

Output: Working TUI that launches, shows a tab bar with placeholder content for each tab, supports tab switching with keyboard, and cleanly exits.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tui-mode/06-RESEARCH.md
@src/cli/args.rs
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TUI dependencies and CLI entry points</name>
  <files>
    Cargo.toml
    src/cli/args.rs
    src/main.rs
  </files>
  <action>
1. Add dependencies to Cargo.toml:
   ```toml
   # TUI (Phase 6)
   ratatui = "0.30"
   crossterm = { version = "0.28", features = ["event-stream"] }
   ```
   Note: ratatui re-exports crossterm, but we need explicit crossterm dep for `event-stream` feature (async EventStream). tokio and futures are already present.

2. In `src/cli/args.rs`:
   - Add `--tui` global flag to `Cli` struct: `#[arg(long, global = true)] pub tui: bool`
   - Add `Ui` variant to `Commands` enum: `/// Launch interactive TUI mode\nUi,`
   - Add `Sync` variant to `Commands` enum with basic args:
     ```rust
     /// Sync directories (one-way mirror)
     Sync(SyncArgs),
     ```
   - Add `SyncArgs` struct:
     ```rust
     #[derive(clap::Args, Debug)]
     pub struct SyncArgs {
         /// Source directory
         pub source: String,
         /// Destination directory
         pub dest: String,
         /// Preview sync changes without executing
         #[arg(long)]
         pub dry_run: bool,
     }
     ```

3. In `src/main.rs`:
   - Add `mod tui;` declaration
   - In the `run()` function, add match arms:
     ```rust
     Commands::Ui => {
         tui::launch_tui()?;
         Ok(())
     }
     Commands::Sync(_args) => {
         eprintln!("flux sync: not yet implemented (coming in Phase 7)");
         Ok(())
     }
     ```
   - Before the command match, check `cli.tui` flag:
     ```rust
     if cli.tui {
         return tui::launch_tui().map_err(|e| FluxError::Io { source: std::io::Error::new(std::io::ErrorKind::Other, e.to_string()) });
     }
     ```
     Note: `launch_tui()` returns `color_eyre::Result<()>`. Convert to FluxError for the main error path. Alternatively, since we don't add color-eyre (project uses anyhow/thiserror), `launch_tui()` should return `Result<(), Box<dyn std::error::Error>>` or `Result<(), FluxError>`. Prefer returning `Result<(), FluxError>` to stay consistent. Map ratatui/crossterm io::Errors to `FluxError::Io`.
  </action>
  <verify>
    `cargo check` passes with no errors. `cargo run -- ui --help` shows the Ui subcommand. `cargo run -- sync --help` shows sync args. `cargo run -- --tui --help` shows the tui flag.
  </verify>
  <done>
    CLI has `flux ui`, `flux --tui`, and `flux sync` entry points. Dependencies compile. `flux sync src dest` prints "not yet implemented".
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TUI module with event loop, Component trait, and App shell</name>
  <files>
    src/tui/mod.rs
    src/tui/event.rs
    src/tui/terminal.rs
    src/tui/action.rs
    src/tui/app.rs
    src/tui/theme.rs
    src/tui/components/mod.rs
    src/tui/components/status_bar.rs
  </files>
  <action>
1. Create `src/tui/mod.rs`:
   - Declare submodules: `mod event; mod terminal; mod action; mod app; pub mod theme; pub mod components;`
   - Export public function `launch_tui() -> Result<(), crate::error::FluxError>`:
     - Create a new tokio runtime (`tokio::runtime::Runtime::new()`) since main.rs is sync
     - Block on `app::run_app()` inside the runtime
     - Alternatively, if easier, make `launch_tui` sync and use `#[tokio::main]` or the existing tokio runtime pattern. Since the project's `main()` is sync and we need async for crossterm EventStream, create a runtime: `let rt = tokio::runtime::Runtime::new()?; rt.block_on(app::run_app())`
     - Map any errors to `FluxError::Io`

2. Create `src/tui/action.rs`:
   - Define `Action` enum:
     ```rust
     pub enum Action {
         Noop,
         Quit,
         SwitchTab(usize),
         ScrollUp,
         ScrollDown,
         Select,
         Back,
         Pause,
         Resume,
         Cancel,
         Refresh,
     }
     ```

3. Create `src/tui/event.rs`:
   - Follow the async EventHandler pattern from research:
     ```rust
     pub enum Event {
         Tick,
         Render,
         Key(crossterm::event::KeyEvent),
         Mouse(crossterm::event::MouseEvent),
         Resize(u16, u16),
         Quit,
     }
     ```
   - `EventHandler` struct with `mpsc::UnboundedSender<Event>`, `mpsc::UnboundedReceiver<Event>`, `JoinHandle<()>`
   - `EventHandler::new(tick_rate: Duration, render_rate: Duration)` spawns tokio task that uses `tokio::select!` with:
     - `crossterm::event::EventStream::new()` via `reader.next().fuse()`
     - `tokio::time::interval(tick_rate).tick()`
     - `tokio::time::interval(render_rate).tick()`
   - Only forward `KeyEventKind::Press` events (avoid key repeat/release duplicates)
   - `pub async fn next(&mut self) -> Event` receives from channel
   - Use `ratatui::crossterm` re-export where possible, but `EventStream` requires the explicit crossterm with event-stream feature
   - Import crossterm directly for EventStream: `use crossterm::event::EventStream;`
   - For other crossterm types use: `use ratatui::crossterm::event::{KeyEvent, KeyEventKind, MouseEvent};`

4. Create `src/tui/terminal.rs`:
   - `pub fn init() -> std::io::Result<ratatui::Terminal<ratatui::backend::CrosstermBackend<std::io::Stderr>>>`:
     - Use `ratatui::init()` which sets up alternate screen, raw mode, and panic hooks automatically
     - Note: ratatui 0.30 `init()` returns `DefaultTerminal`. Use that type alias instead of spelling out the full type.
   - `pub fn restore()`:
     - Call `ratatui::restore()` to leave alternate screen, disable raw mode
   - Keep these thin wrappers -- the main value is centralized setup/teardown.

5. Create `src/tui/theme.rs`:
   - Define color constants for consistent styling:
     ```rust
     use ratatui::style::{Color, Modifier, Style};

     pub const TAB_ACTIVE: Style = Style::new().fg(Color::Yellow).add_modifier(Modifier::BOLD);
     pub const TAB_INACTIVE: Style = Style::new().fg(Color::Gray);
     pub const HEADER: Style = Style::new().fg(Color::Cyan).add_modifier(Modifier::BOLD);
     pub const SELECTED: Style = Style::new().bg(Color::DarkGray).add_modifier(Modifier::BOLD);
     pub const SPEED: Style = Style::new().fg(Color::Cyan);
     pub const SUCCESS: Style = Style::new().fg(Color::Green);
     pub const ERROR: Style = Style::new().fg(Color::Red);
     pub const WARNING: Style = Style::new().fg(Color::Yellow);
     pub const BORDER: Style = Style::new().fg(Color::White);
     ```
   Note: `Style::new()` is const in ratatui 0.30. If const method chaining doesn't work, use `Style { fg: Some(Color::Yellow), add_modifier: Modifier::BOLD, ..Style::new() }` or non-const functions assigned at runtime. Check compilation.

6. Create `src/tui/components/mod.rs`:
   - Define Component trait:
     ```rust
     use ratatui::Frame;
     use ratatui::layout::Rect;
     use ratatui::crossterm::event::KeyEvent;
     use super::action::Action;

     pub mod status_bar;

     pub trait Component {
         fn handle_key_event(&mut self, key: KeyEvent) -> Action {
             let _ = key;
             Action::Noop
         }
         fn update(&mut self) {}
         fn render(&mut self, frame: &mut Frame, area: Rect);
     }
     ```

7. Create `src/tui/components/status_bar.rs`:
   - Implement a `StatusBar` component that renders key hints at the bottom:
     ```rust
     pub struct StatusBar {
         pub hints: Vec<(String, String)>,  // (key, description)
     }
     ```
   - Default hints: `q`=Quit, `1-4`=Switch Tab, `Tab`=Next Tab
   - Render as a horizontal bar: `q:Quit | 1:Dashboard | 2:Files | 3:Queue | 4:History`
   - Use `Paragraph` widget with centered or left-aligned text
   - Implement `Component` trait (render only, no key handling)

8. Create `src/tui/app.rs`:
   - Define `ActiveTab` enum: `Dashboard, FileBrowser, Queue, History`
   - Define `App` struct:
     ```rust
     pub struct App {
         active_tab: ActiveTab,
         should_quit: bool,
         status_bar: StatusBar,
     }
     ```
   - For now, use placeholder rendering for each tab (just a Block with title "Dashboard", "Files", etc.)
   - `App::new()` constructor
   - `App::handle_key_event(&mut self, key: KeyEvent) -> Action`:
     - Global keys first (checked before delegating to active tab):
       - `q` -> `Action::Quit`
       - `1` -> switch to Dashboard
       - `2` -> switch to FileBrowser
       - `3` -> switch to Queue
       - `4` -> switch to History
       - `Tab` -> cycle to next tab
       - `Shift+Tab` (BackTab) -> cycle to previous tab
     - Then delegate to active tab's component (placeholder for now)
   - `App::render(&mut self, frame: &mut Frame)`:
     - Layout: vertical split into 3 chunks:
       - Length(3): Tab bar (ratatui `Tabs` widget)
       - Min(1): Active tab content area
       - Length(1): Status bar
     - Render `Tabs` widget with ["Dashboard", "Files", "Queue", "History"], highlighting active
     - Render placeholder `Block::bordered().title(tab_name)` in content area
     - Render `StatusBar` in bottom area
   - `pub async fn run_app() -> Result<(), std::io::Error>`:
     - Call `terminal::init()` (or `ratatui::init()`) to get terminal
     - Create `EventHandler::new(Duration::from_millis(250), Duration::from_millis(50))` -- 20fps render, 4Hz tick
     - Create `App::new()`
     - Main loop:
       ```rust
       loop {
           let event = events.next().await;
           match event {
               Event::Render => { terminal.draw(|frame| app.render(frame))?; }
               Event::Tick => { app.on_tick(); }
               Event::Key(key) => {
                   let action = app.handle_key_event(key);
                   match action {
                       Action::Quit => break,
                       _ => {}
                   }
               }
               Event::Resize(_, _) => {} // ratatui handles resize on next draw
               _ => {}
           }
       }
       ```
     - After loop: call `terminal::restore()` (or `ratatui::restore()`)
     - Return Ok(())
  </action>
  <verify>
    `cargo build` succeeds. Run `cargo run -- ui` and verify: TUI launches in alternate screen, shows tab bar with 4 tabs, shows placeholder content, tab switching works with 1/2/3/4/Tab keys, 'q' exits cleanly, terminal is restored after exit. Test panic recovery by temporarily adding a panic in on_tick -- terminal should still restore.
  </verify>
  <done>
    TUI launches with `flux ui`, shows tab navigation with 4 tabs, accepts keyboard input for tab switching and quit, terminal cleanly restores on exit. Component trait exists for future views to implement.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with no warnings related to new code
2. `flux ui` launches the TUI in alternate screen mode
3. Tab switching with 1/2/3/4 keys works, Tab/Shift+Tab cycles
4. `q` exits TUI and terminal is fully restored (cursor visible, echo on, not in raw mode)
5. `flux --tui` also launches the TUI
6. `flux sync src dest` prints "not yet implemented" message
7. `flux --help` shows ui, sync commands and --tui flag
</verification>

<success_criteria>
- TUI launches and exits cleanly via both `flux ui` and `flux --tui`
- Tab bar visible with Dashboard/Files/Queue/History tabs
- Keyboard navigation works (number keys, Tab, q to quit)
- Terminal restores correctly after exit
- `flux sync` skeleton exists
- All existing tests still pass (`cargo test`)
</success_criteria>

<output>
After completion, create `.planning/phases/06-tui-mode/06-01-SUMMARY.md`
</output>
