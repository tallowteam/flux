---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/cli/mod.rs
  - src/cli/args.rs
  - src/error.rs
  - src/config/mod.rs
  - src/config/types.rs
autonomous: true
requirements:
  - CLI-01
  - CLI-04
  - CONF-04
  - CORE-09

must_haves:
  truths:
    - "User can run `flux --help` and see usage information with cp subcommand"
    - "User can run `flux cp --help` and see source, dest, -r, --exclude, --include, -v, -q flags"
    - "Invalid commands produce helpful error messages with suggestions"
    - "Verbosity flags (-q, -v, -vv) are parsed and control tracing output level"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "clap"
    - path: "src/main.rs"
      provides: "Entry point with CLI parsing, tracing setup, error display"
      min_lines: 30
    - path: "src/cli/args.rs"
      provides: "Clap derive structs for Cli, Commands, CpArgs"
      contains: "derive(Parser)"
    - path: "src/error.rs"
      provides: "FluxError enum with suggestion() method"
      contains: "FluxError"
    - path: "src/config/types.rs"
      provides: "Verbosity enum and FluxConfig struct"
      contains: "Verbosity"
  key_links:
    - from: "src/main.rs"
      to: "src/cli/args.rs"
      via: "Cli::parse()"
      pattern: "Cli::parse"
    - from: "src/main.rs"
      to: "src/error.rs"
      via: "display_error function for user-facing output"
      pattern: "display_error"
---

<objective>
Scaffold the Flux Rust project with CLI argument parsing, structured error handling, configuration types, and verbosity-controlled logging.

Purpose: Establish the project skeleton so all subsequent plans can build on a working binary that parses arguments and handles errors gracefully.
Output: A compilable `flux` binary that parses `flux cp <source> <dest>` commands with all flags, displays help text, and produces helpful error messages.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cargo project with CLI parsing and module structure</name>
  <files>
    Cargo.toml
    src/main.rs
    src/cli/mod.rs
    src/cli/args.rs
    src/config/mod.rs
    src/config/types.rs
  </files>
  <action>
Create the Rust project with `cargo init` in the project root (if Cargo.toml doesn't exist) or create Cargo.toml manually.

**Cargo.toml:** Set package name to "flux", version "0.1.0", edition "2021". Add all dependencies from research:
- clap = { version = "4.5", features = ["derive"] }
- tokio = { version = "1", features = ["full"] }
- indicatif = "0.18"
- walkdir = "2.5"
- globset = "0.4"
- serde = { version = "1.0", features = ["derive"] }
- toml = "0.8"
- dirs = "5"
- thiserror = "2"
- anyhow = "1"
- tracing = "0.1"
- tracing-subscriber = { version = "0.3", features = ["env-filter"] }

Dev-dependencies:
- tempfile = "3"
- assert_cmd = "2"
- predicates = "3"

**src/cli/args.rs:** Implement clap derive structs exactly as specified in the research:
- `Cli` struct with `#[derive(Parser)]`: subcommand field, `--verbose`/`-v` (action = Count, global = true), `--quiet`/`-q` (bool, global = true)
- `Commands` enum with `Cp(CpArgs)` variant
- `CpArgs` struct: `source: PathBuf`, `dest: PathBuf`, `--recursive`/`-r` (bool), `--exclude` (Vec<String>, action = Append), `--include` (Vec<String>, action = Append)
- Use `#[command(name = "flux", version, about = "Blazing-fast file transfer")]`

**src/cli/mod.rs:** Re-export args module (`pub mod args;`)

**src/config/types.rs:** Define:
- `Verbosity` enum: `Quiet`, `Normal`, `Verbose`, `Trace`
- Implement `From<(bool, u8)>` for Verbosity to convert from (quiet, verbose_count) tuple
- `FluxConfig` struct with `verbosity: Verbosity` field (skeleton for future config)

**src/config/mod.rs:** Re-export types module (`pub mod types;`)

**src/main.rs:**
- Declare modules: `mod cli; mod config; mod error;` (backend, transfer, progress will be added in Plan 02/03)
- Parse CLI with `Cli::parse()`
- Convert verbosity flags to tracing filter: quiet="error", 0="info", 1="debug", 2+="trace"
- Initialize tracing-subscriber with env filter (respect RUST_LOG env var as override), write to stderr
- Match on `cli.command` — for `Commands::Cp(args)`, print a placeholder message like "Copy command received" (transfer execution wired in Plan 03)
- Wrap main in error handling that calls `display_error` on FluxError

Cross-platform note: Use `std::path::PathBuf` for all paths. Do NOT use string manipulation for paths.
  </action>
  <verify>
Run `cargo build` — must compile with zero errors. Run `cargo run -- --help` — must show flux help with cp subcommand. Run `cargo run -- cp --help` — must show source, dest, -r, --exclude, --include options. Run `cargo run -- cp nonexistent.txt dest.txt` — should print placeholder message (actual copy not implemented yet).
  </verify>
  <done>
Binary compiles. `flux --help` shows version and cp subcommand. `flux cp --help` shows all arguments and flags. Verbosity flags are accepted without error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement structured error types with helpful suggestions</name>
  <files>
    src/error.rs
    src/main.rs
  </files>
  <action>
**src/error.rs:** Create the FluxError enum using thiserror exactly as specified in research:
- `SourceNotFound { path: PathBuf }` — "Source not found: {path}" with display using path.display()
- `DestinationNotWritable { path: PathBuf }` — "Destination not writable: {path}"
- `PermissionDenied { path: PathBuf }` — "Permission denied: {path}"
- `IsDirectory { path: PathBuf }` — "Source is a directory, use -r flag for recursive copy"
- `InvalidPattern { pattern: String, reason: String }` — "Invalid glob pattern '{pattern}': {reason}"
- `Io { #[from] source: std::io::Error }` — "I/O error: {source}"
- `Config(String)` — "Configuration error: {0}"
- `DestinationIsSubdirectory { source: PathBuf, dest: PathBuf }` — "Destination is inside source directory"

Implement `suggestion()` method on FluxError returning `Option<&str>`:
- SourceNotFound: "Check the path exists and spelling is correct."
- PermissionDenied: "Try running with elevated privileges, or check file permissions."
- IsDirectory: "Use 'flux cp -r <source> <dest>' for directory copies."
- DestinationNotWritable: "Check that the destination directory exists and you have write permission."
- InvalidPattern: "Check glob syntax. Examples: '*.log', '**/*.tmp', 'build/'"
- DestinationIsSubdirectory: "Choose a destination outside the source directory."
- Others: None

Implement conversion `From<globset::Error>` for FluxError, mapping to `InvalidPattern`.
Implement conversion from `walkdir::Error` for FluxError, mapping to `Io` or `PermissionDenied` as appropriate.
Implement conversion from `std::path::StripPrefixError` for FluxError.

**src/main.rs:** Add `display_error` function that:
1. Prints "error: {err}" to stderr
2. If `err.suggestion()` returns Some, prints "  hint: {suggestion}" to stderr
3. Exits with code 1

Wire this into main: use `if let Err(e)` pattern on the command dispatch (not anyhow's auto-display) so FluxError suggestions are rendered. For non-FluxError anyhow errors, still display them cleanly.

Use a pattern like:
```rust
fn main() {
    // ... parse, tracing setup ...
    if let Err(err) = run(cli) {
        display_error(&err);
        std::process::exit(1);
    }
}

fn run(cli: Cli) -> Result<(), FluxError> {
    match cli.command {
        Commands::Cp(args) => { /* placeholder */ Ok(()) }
    }
}
```
  </action>
  <verify>
Run `cargo build` — must compile with zero errors. Run `cargo test` — all tests pass. Manually verify that creating a FluxError::SourceNotFound and calling .suggestion() returns the expected hint string. Verify the Display impl produces the expected message format.
  </verify>
  <done>
FluxError enum compiles with all variants. Each variant has a human-readable Display message. suggestion() returns context-specific fix hints for all actionable error types. display_error renders "error:" + "hint:" format to stderr. From conversions exist for std::io::Error, globset::Error, walkdir::Error, and StripPrefixError.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with no errors or warnings
2. `cargo run -- --help` shows: flux version, "Blazing-fast file transfer", cp subcommand
3. `cargo run -- cp --help` shows: source, dest positional args; -r/--recursive; --exclude; --include; -v/--verbose; -q/--quiet
4. `cargo run -- --version` shows version number
5. `cargo run -- invalid-command` shows clap error with "did you mean" suggestion
6. Module structure matches the planned layout (cli/, config/, error.rs)
</verification>

<success_criteria>
- `flux` binary compiles and runs on the current platform
- CLI accepts `flux cp <source> <dest>` with all Phase 1 flags
- Help text is auto-generated and informative
- Error types are defined with helpful suggestion messages
- Verbosity flags control tracing subscriber filter level
- All paths use std::path::PathBuf (cross-platform)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
