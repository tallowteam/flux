---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/backend/mod.rs
  - src/backend/local.rs
  - src/transfer/mod.rs
  - src/transfer/copy.rs
  - src/progress/mod.rs
  - src/progress/bar.rs
  - src/main.rs
autonomous: true
requirements:
  - PROT-01
  - CORE-01
  - CORE-04

must_haves:
  truths:
    - "User can copy a single file with `flux cp source.txt dest.txt` and file content is identical"
    - "User sees a progress bar during file copy showing percentage, bytes, speed, and ETA"
    - "Progress bar renders to stderr (not stdout) and is hidden in quiet mode"
    - "Copy of a large file (>1MB) shows smooth progress updates"
  artifacts:
    - path: "src/backend/mod.rs"
      provides: "FluxBackend trait definition, FileStat, FileEntry, BackendFeatures"
      contains: "trait FluxBackend"
    - path: "src/backend/local.rs"
      provides: "LocalBackend implementing FluxBackend with std::fs"
      contains: "impl FluxBackend for LocalBackend"
    - path: "src/transfer/copy.rs"
      provides: "ProgressReader wrapper and copy_file_with_progress function"
      contains: "ProgressReader"
    - path: "src/progress/bar.rs"
      provides: "Progress bar factory functions with indicatif"
      contains: "create_file_progress"
  key_links:
    - from: "src/transfer/copy.rs"
      to: "src/backend/local.rs"
      via: "LocalBackend::open_read/open_write for file handles"
      pattern: "open_read|open_write"
    - from: "src/transfer/copy.rs"
      to: "src/progress/bar.rs"
      via: "ProgressBar passed to ProgressReader"
      pattern: "ProgressReader::new"
    - from: "src/main.rs"
      to: "src/transfer/copy.rs"
      via: "Dispatches cp command to transfer::copy_file_with_progress"
      pattern: "copy_file_with_progress|execute_copy"
---

<objective>
Implement the FluxBackend trait, LocalBackend for local filesystem operations, and single-file copy with real-time progress bar display.

Purpose: Establish the backend abstraction that all future protocols will implement, and deliver the first working file transfer with progress feedback.
Output: `flux cp source.txt dest.txt` copies a file with a live progress bar showing percentage, bytes transferred, speed, and ETA.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FluxBackend trait and LocalBackend</name>
  <files>
    src/backend/mod.rs
    src/backend/local.rs
    src/main.rs
  </files>
  <action>
**src/backend/mod.rs:** Define the core backend abstraction:

- `FileStat` struct: `size: u64`, `is_dir: bool`, `is_file: bool`, `modified: Option<std::time::SystemTime>`, `permissions: Option<u32>`. Derive Debug, Clone.
- `FileEntry` struct: `path: std::path::PathBuf`, `stat: FileStat`. Derive Debug, Clone.
- `BackendFeatures` struct: `supports_seek: bool`, `supports_parallel: bool`, `supports_permissions: bool`. Derive Debug, Clone.
- `FluxBackend` trait (Send + Sync) with methods:
  - `fn stat(&self, path: &Path) -> Result<FileStat, FluxError>`
  - `fn list_dir(&self, path: &Path) -> Result<Vec<FileEntry>, FluxError>`
  - `fn open_read(&self, path: &Path) -> Result<Box<dyn std::io::Read + Send>, FluxError>`
  - `fn open_write(&self, path: &Path) -> Result<Box<dyn std::io::Write + Send>, FluxError>`
  - `fn create_dir_all(&self, path: &Path) -> Result<(), FluxError>`
  - `fn features(&self) -> BackendFeatures`

Use synchronous trait (NOT async). See research: "Phase 1 uses synchronous FluxBackend trait methods because local file I/O is inherently blocking."

Re-export: `pub mod local;`

**src/backend/local.rs:** Implement `LocalBackend`:

- `LocalBackend` struct (empty/unit struct for now, no fields needed)
- `impl FluxBackend for LocalBackend`:
  - `stat`: Use `std::fs::metadata`, convert to FileStat. Map `io::ErrorKind::NotFound` to `FluxError::SourceNotFound`. Map `PermissionDenied` to `FluxError::PermissionDenied`.
  - `list_dir`: Use `std::fs::read_dir`, collect entries into Vec<FileEntry>.
  - `open_read`: Use `std::fs::File::open`. Wrap in `BufReader::with_capacity(256 * 1024, file)` and box it. Map NotFound to SourceNotFound, PermissionDenied to PermissionDenied.
  - `open_write`: Use `std::fs::File::create`. Wrap in `BufWriter::with_capacity(256 * 1024, file)` and box it. Map PermissionDenied to DestinationNotWritable.
  - `create_dir_all`: Use `std::fs::create_dir_all`.
  - `features`: Return `BackendFeatures { supports_seek: true, supports_parallel: true, supports_permissions: cfg!(unix) }`

**src/main.rs:** Add `mod backend;` declaration. Do NOT change existing code beyond adding the module declaration.

Cross-platform: Use only `std::path::Path` methods. On `stat()`, get permissions as `mode()` on Unix (behind `#[cfg(unix)]`) and `None` on other platforms.
  </action>
  <verify>
Run `cargo build` — must compile. Write a unit test in `src/backend/local.rs` using `#[cfg(test)]` module:
- Test `stat` on an existing file (use `file!()` macro to get current source file path)
- Test `open_read` on same file, read a few bytes
- Test `stat` on nonexistent path returns SourceNotFound error
Run `cargo test` — all tests pass.
  </verify>
  <done>
FluxBackend trait is defined with all 6 methods. LocalBackend implements all methods correctly. Error mapping converts io::Error variants to appropriate FluxError variants. Unit tests confirm stat, open_read, and error cases work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement progress-tracking file copy with indicatif progress bar</name>
  <files>
    src/transfer/mod.rs
    src/transfer/copy.rs
    src/progress/mod.rs
    src/progress/bar.rs
    src/main.rs
  </files>
  <action>
**src/progress/bar.rs:** Create progress bar factory functions:

- `create_file_progress(total_bytes: u64, quiet: bool) -> ProgressBar`:
  - If quiet, return `ProgressBar::hidden()`
  - Create ProgressBar with total_bytes length
  - Set draw target to `ProgressDrawTarget::stderr()` (CRITICAL: progress on stderr, not stdout)
  - Set style template: `"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec}, ETA {eta})"`
  - Progress chars: `"=>-"`

- `create_directory_progress(total_files: u64, quiet: bool) -> ProgressBar`:
  - Same quiet check
  - Style template: `"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} files ({per_sec}, ETA {eta}) {msg}"`
  - This is for Plan 03 but define it now to avoid touching this file later.

**src/progress/mod.rs:** `pub mod bar;`

**src/transfer/copy.rs:** Implement the copy engine:

- `ProgressReader<R: Read>` struct: wraps inner `R` and `ProgressBar`. Implement `Read` trait — on each `read()`, call `self.progress.inc(bytes_read as u64)`. Exactly as shown in research Pattern 2.

- `copy_file_with_progress(source: &Path, dest: &Path, progress: &ProgressBar) -> Result<u64, FluxError>`:
  - Open source with `std::fs::File::open` (map errors to FluxError)
  - Get source size from metadata, call `progress.set_length(src_size)`
  - Wrap in `BufReader::with_capacity(256 * 1024, src_file)`
  - Wrap BufReader in `ProgressReader::new(reader, progress.clone())`
  - Create dest with `std::fs::File::create` (ensure parent dir exists first with `create_dir_all`)
  - Wrap in `BufWriter::with_capacity(256 * 1024, dest_file)`
  - Use `std::io::copy(&mut reader, &mut writer)` for the actual transfer
  - Call `writer.flush()?` after copy
  - Call `progress.finish_with_message("done")`
  - Return bytes copied

**src/transfer/mod.rs:** Create the top-level transfer dispatcher:

- `pub mod copy;` (filter module added in Plan 03)
- `pub fn execute_copy(args: CpArgs, quiet: bool) -> Result<(), FluxError>`:
  - Validate: source exists (using std::fs::metadata, map to SourceNotFound)
  - Validate: if source is a directory and !args.recursive, return FluxError::IsDirectory
  - Validate: source != dest (canonicalize both, compare)
  - For single file (source.is_file()):
    - Get file size from metadata
    - Create progress bar with `create_file_progress(size, quiet)`
    - Call `copy_file_with_progress(&args.source, &args.dest, &progress)`
    - Print summary: "Copied {bytes} bytes" (via tracing::info)
  - For directory: print "Directory copy not yet implemented" and return Ok (wired in Plan 03)

**src/main.rs:** Update to wire the transfer module:
- Add `mod transfer; mod progress;`
- In the `Commands::Cp(args)` match arm, call `transfer::execute_copy(args, cli.quiet)?`
- Remove the placeholder message from Plan 01
  </action>
  <verify>
Run `cargo build` — must compile with zero errors.

Test single file copy:
1. Create a test file: `echo "hello world" > /tmp/flux_test_source.txt`
2. Run: `cargo run -- cp /tmp/flux_test_source.txt /tmp/flux_test_dest.txt`
3. Verify dest content matches source
4. Verify progress bar appeared on stderr during copy

Test quiet mode:
1. `cargo run -- -q cp /tmp/flux_test_source.txt /tmp/flux_test_dest2.txt`
2. Should produce no progress bar output

Test error cases:
1. `cargo run -- cp /tmp/nonexistent.txt /tmp/dest.txt` — should show "error: Source not found" + hint
2. `cargo run -- cp /tmp/ /tmp/dest/` (without -r) — should show "Source is a directory" + hint

Run `cargo test` — all tests pass.
  </verify>
  <done>
`flux cp source.txt dest.txt` copies the file with a visible progress bar showing bytes, speed, and ETA. Progress renders to stderr. Quiet mode suppresses progress. Error messages with hints appear for: missing source, directory-without-recursive, permission denied. ProgressReader correctly tracks bytes through the Read trait. File content is identical after copy.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `flux cp small_file.txt dest.txt` copies correctly, content matches
3. `flux cp large_file.bin dest.bin` shows smooth progress bar with speed and ETA
4. `flux -q cp file.txt dest.txt` copies without progress bar output
5. `flux cp nonexistent.txt dest.txt` shows error with hint
6. `flux cp some_dir/ dest/` (without -r) shows "use -r flag" error with hint
7. `cargo test` passes all unit tests for LocalBackend
</verification>

<success_criteria>
- FluxBackend trait defined with all methods, ready for future protocol implementations
- LocalBackend passes unit tests for stat, read, write, error handling
- Single file copy works end-to-end with progress display
- Progress bar shows percentage, bytes transferred, speed, ETA on stderr
- Quiet mode hides progress bar
- Error messages include actionable hints
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
