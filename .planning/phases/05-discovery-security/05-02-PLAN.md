---
phase: 05-discovery-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/discovery/mod.rs
  - src/discovery/mdns.rs
  - src/discovery/service.rs
  - src/net/mod.rs
  - src/net/protocol.rs
autonomous: true
requirements:
  - DISC-01
  - DISC-02

must_haves:
  truths:
    - "mDNS browsing discovers Flux services registered on the LAN within a timeout period"
    - "mDNS registration advertises a Flux service with device name, port, and version"
    - "Protocol message types cover the complete transfer lifecycle: handshake, file header, data chunks, completion, error"
    - "Discovered devices have friendly names, IP addresses, and port numbers"
  artifacts:
    - path: "src/discovery/mdns.rs"
      provides: "mDNS service registration and browsing"
      exports: ["register_flux_service", "discover_flux_devices"]
    - path: "src/discovery/service.rs"
      provides: "FluxService and DiscoveredDevice types"
      exports: ["DiscoveredDevice", "FluxService", "SERVICE_TYPE", "DEFAULT_PORT"]
    - path: "src/net/protocol.rs"
      provides: "Transfer protocol message types"
      exports: ["FluxMessage"]
  key_links:
    - from: "src/discovery/mdns.rs"
      to: "mdns-sd crate"
      via: "ServiceDaemon browse/register"
      pattern: "ServiceDaemon::new"
    - from: "src/discovery/service.rs"
      to: "src/discovery/mdns.rs"
      via: "shared SERVICE_TYPE constant"
      pattern: "_flux._tcp.local."
---

<objective>
Implement the LAN discovery module (mDNS browsing and registration) and define the transfer protocol message types that sender/receiver will use for peer-to-peer communication.

Purpose: Provides device discovery so users can find other Flux instances on the network, and defines the message protocol that Plan 03 will use for actual file transfer.
Output: Compilable discovery and net modules with unit tests.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-discovery-security/05-RESEARCH.md

Key notes from research:
- mdns-sd is synchronous (has its own internal thread), no tokio needed for discovery
- Service type MUST be "_flux._tcp.local." with trailing dot
- ServiceInfo carries TXT properties for version and metadata
- bincode 2.x has a different API than 1.x: use bincode::serde for serde compat, or use Encode/Decode derives
- LengthDelimitedCodec from tokio-util for message framing over TCP
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement discovery module (mDNS registration and browsing)</name>
  <files>
    src/discovery/mod.rs
    src/discovery/service.rs
    src/discovery/mdns.rs
    src/main.rs
  </files>
  <action>
    Create `src/discovery/mod.rs` exporting `pub mod mdns; pub mod service;`.

    Create `src/discovery/service.rs` with:

    1. Constants:
       - `pub const SERVICE_TYPE: &str = "_flux._tcp.local.";`
       - `pub const DEFAULT_PORT: u16 = 9741;`

    2. `DiscoveredDevice` struct (Debug, Clone):
       - `name: String` -- instance/friendly name
       - `host: String` -- IP address
       - `port: u16`
       - `version: Option<String>` -- from TXT record
       - `public_key: Option<String>` -- base64 public key from TXT record (for TOFU)

    3. `FluxService` struct -- represents our own service registration:
       - `device_name: String`
       - `port: u16`

       `FluxService::new(device_name: Option<String>, port: u16) -> Self` -- if device_name is None, use `gethostname()` to get hostname as friendly name. Sanitize hostname: replace non-alphanumeric (except hyphen) with hyphen, truncate to 63 chars (DNS label limit).

    Create `src/discovery/mdns.rs` with:

    1. `register_flux_service(service: &FluxService, public_key: Option<&str>) -> Result<mdns_sd::ServiceDaemon, FluxError>`:
       - Create ServiceDaemon
       - Build ServiceInfo with SERVICE_TYPE, device name, hostname.local., port
       - Add TXT properties: "version" = CARGO_PKG_VERSION, optionally "pubkey" = public_key
       - Call `.enable_addr_auto()` on ServiceInfo
       - Register and return daemon (caller keeps alive to maintain registration)
       - Map errors to FluxError::DiscoveryError

    2. `discover_flux_devices(timeout_secs: u64) -> Result<Vec<DiscoveredDevice>, FluxError>`:
       - Create ServiceDaemon, call browse(SERVICE_TYPE)
       - Loop with recv_timeout(500ms) until deadline
       - On ServiceResolved: extract name (instance name from fullname), first IP address, port, TXT properties (version, pubkey)
       - Deduplicate by name (take first seen)
       - Shutdown daemon, return collected devices
       - Map errors to FluxError::DiscoveryError

    Add `mod discovery;` to src/main.rs module declarations (after `mod security;` or after existing modules if Plan 01 hasn't run yet -- handle both cases).

    NOTE: mdns-sd runs its own thread internally. Do NOT use tokio for discovery. The browse/register calls are synchronous.

    Write unit tests in service.rs:
    - Test FluxService::new with None hostname (uses gethostname)
    - Test FluxService::new with provided name
    - Test hostname sanitization (special chars -> hyphens, length truncation)
    - Test SERVICE_TYPE constant format

    Note: mDNS network tests cannot run in CI without a network. Mark any integration-level mDNS tests with `#[ignore]` and document why.
  </action>
  <verify>
    `cargo test discovery` passes all unit tests. `cargo check` passes with no errors.
  </verify>
  <done>
    Discovery module compiles. DiscoveredDevice and FluxService types are defined. register_flux_service and discover_flux_devices functions are implemented. Unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define transfer protocol message types</name>
  <files>
    src/net/mod.rs
    src/net/protocol.rs
    src/main.rs
  </files>
  <action>
    Create `src/net/mod.rs` exporting `pub mod protocol;`.

    Create `src/net/protocol.rs` with:

    1. `FluxMessage` enum (Serialize, Deserialize, Debug, Clone):
       - `Handshake { version: u8, device_name: String, public_key: Option<Vec<u8>> }` -- sent by sender to identify and optionally request encryption (32-byte X25519 public key)
       - `HandshakeAck { accepted: bool, public_key: Option<Vec<u8>>, reason: Option<String> }` -- receiver's response, includes their public key if encryption accepted
       - `FileHeader { filename: String, size: u64, checksum: Option<String>, encrypted: bool }` -- metadata before data transfer
       - `DataChunk { offset: u64, data: Vec<u8>, nonce: Option<Vec<u8>> }` -- file data (nonce is 24 bytes when encrypted, Vec for serde compat)
       - `TransferComplete { filename: String, bytes_received: u64, checksum_verified: Option<bool> }` -- receiver acknowledgement
       - `Error { message: String }` -- transfer error

    2. `PROTOCOL_VERSION: u8 = 1` constant.

    3. Helper functions for serialization with bincode 2.x:
       - `pub fn encode_message(msg: &FluxMessage) -> Result<Vec<u8>, FluxError>` -- serialize using bincode. NOTE: bincode 2.x API uses `bincode::serde::encode_to_vec(msg, bincode::config::standard())` or similar. Check the actual 2.x API. If the API is too different, fall back to `serde_json` for message serialization (simpler, slightly larger, but correct). Document the choice.
       - `pub fn decode_message(bytes: &[u8]) -> Result<FluxMessage, FluxError>` -- deserialize
       - Map errors to FluxError::TransferError

    4. `MAX_FRAME_SIZE: usize = 2 * 1024 * 1024` constant (2MB max frame for LengthDelimitedCodec).
    5. `CHUNK_SIZE: usize = 256 * 1024` constant (256KB data chunks for transfer, matching existing buffer sizes).

    Add `mod net;` to src/main.rs module declarations.

    Write unit tests:
    - Test encode/decode round-trip for each FluxMessage variant
    - Test that Handshake with public_key encodes/decodes correctly
    - Test that DataChunk with nonce encodes/decodes correctly
    - Test MAX_FRAME_SIZE and CHUNK_SIZE constants are reasonable
  </action>
  <verify>
    `cargo test net::protocol` passes all unit tests. `cargo check` passes. FluxMessage can be serialized and deserialized.
  </verify>
  <done>
    FluxMessage enum defines complete transfer protocol. encode_message/decode_message handle serialization. All message variants round-trip correctly in tests. Constants defined for frame and chunk sizes.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` -- discovery and net modules compile
2. `cargo test discovery` -- discovery unit tests pass
3. `cargo test net::protocol` -- protocol unit tests pass
4. `cargo test` -- all existing tests still pass
</verification>

<success_criteria>
- mDNS registration function creates valid _flux._tcp.local. service entries
- mDNS discovery function collects resolved devices with name, host, port, version
- FluxMessage covers full transfer lifecycle (handshake through completion)
- All message types can be serialized and deserialized
- DiscoveredDevice captures friendly name, address, port, and optional public key
</success_criteria>

<output>
After completion, create `.planning/phases/05-discovery-security/05-02-SUMMARY.md`
</output>
