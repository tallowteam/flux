---
phase: 05-discovery-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/error.rs
  - src/security/mod.rs
  - src/security/crypto.rs
  - src/security/trust.rs
  - src/main.rs
autonomous: true
requirements:
  - SEC-01
  - SEC-02
  - SEC-03

must_haves:
  truths:
    - "EncryptedChannel can perform X25519 key exchange and encrypt/decrypt data chunks with XChaCha20-Poly1305"
    - "TrustStore can load, save, add, remove, and verify trusted device public keys from JSON file"
    - "Device identity key pair is generated lazily on first security feature use and persists in config directory"
    - "Trust verification returns Trusted, Unknown, or KeyChanged status for peer public keys"
  artifacts:
    - path: "Cargo.toml"
      provides: "Phase 5 dependencies"
      contains: "mdns-sd"
    - path: "src/security/crypto.rs"
      provides: "X25519 key exchange and XChaCha20-Poly1305 encryption"
      exports: ["EncryptedChannel", "DeviceIdentity"]
    - path: "src/security/trust.rs"
      provides: "TOFU trust store with JSON persistence"
      exports: ["TrustStore", "TrustedDevice", "TrustStatus"]
    - path: "src/error.rs"
      provides: "Discovery and encryption error variants"
      contains: "DiscoveryError"
  key_links:
    - from: "src/security/crypto.rs"
      to: "x25519-dalek + chacha20poly1305"
      via: "EphemeralSecret, PublicKey, XChaCha20Poly1305"
      pattern: "XChaCha20Poly1305"
    - from: "src/security/trust.rs"
      to: "config directory"
      via: "TrustStore::load/save with JSON"
      pattern: "trusted_devices\\.json"
---

<objective>
Add all Phase 5 cargo dependencies and implement the security module: X25519 key exchange, XChaCha20-Poly1305 authenticated encryption, device identity key management, and trust-on-first-use (TOFU) device store.

Purpose: Provides the cryptographic foundation that send/receive commands will use for optional end-to-end encryption and device authentication. These are standalone library modules with no CLI integration yet.
Output: Compilable security module with crypto, trust, identity functionality and unit tests.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-discovery-security/05-RESEARCH.md

Key existing patterns:
- Config directory: config::paths::flux_config_dir() returns platform config path
- Data directory: config::paths::flux_data_dir() returns platform data path
- FLUX_CONFIG_DIR env var override for test isolation
- Error handling: FluxError enum with suggestion() method in src/error.rs
- JSON persistence: serde_json for trust store (matches QueueStore/HistoryStore patterns)
- Atomic writes: write to .tmp then rename (matches AliasStore pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Phase 5 dependencies and new FluxError variants</name>
  <files>
    Cargo.toml
    src/error.rs
  </files>
  <action>
    Add ALL Phase 5 dependencies to Cargo.toml:
    ```
    # Discovery (Phase 5)
    mdns-sd = "0.18"
    gethostname = "0.5"

    # Encryption (Phase 5)
    chacha20poly1305 = "0.10"
    x25519-dalek = { version = "2", features = ["static_secrets"] }
    rand = "0.9"
    base64 = "0.22"

    # Network protocol (Phase 5)
    tokio-util = { version = "0.7", features = ["codec"] }
    bincode = { version = "2", features = ["serde"] }
    futures = "0.3"
    ```

    Add new error variants to FluxError in src/error.rs:
    - `DiscoveryError(String)` -- mDNS discovery failures
    - `EncryptionError(String)` -- crypto operations failures
    - `TrustError(String)` -- trust store operations
    - `TransferError(String)` -- peer-to-peer transfer protocol errors

    Add suggestion() entries for each new variant:
    - DiscoveryError: "Check that your firewall allows mDNS (UDP port 5353) and no other Flux instance is running."
    - EncryptionError: "The encryption handshake failed. Ensure both devices are using compatible Flux versions."
    - TrustError: "Check trusted devices with `flux trust list`. Use `flux trust rm <device>` to remove stale entries."
    - TransferError: "Check that the receiver is running (`flux receive`) and reachable on the network."

    Run `cargo check` to verify all dependencies resolve.
  </action>
  <verify>
    `cargo check` passes with no errors. New error variants exist in error.rs with Display and suggestion support.
  </verify>
  <done>
    Cargo.toml has all Phase 5 dependencies. FluxError has DiscoveryError, EncryptionError, TrustError, TransferError variants with suggestions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement security module (crypto, trust store, device identity)</name>
  <files>
    src/security/mod.rs
    src/security/crypto.rs
    src/security/trust.rs
    src/main.rs
  </files>
  <action>
    Create `src/security/mod.rs` exporting `pub mod crypto; pub mod trust;`.

    Create `src/security/crypto.rs` with:

    1. `DeviceIdentity` struct:
       - Fields: `secret_key: x25519_dalek::StaticSecret`, `public_key: x25519_dalek::PublicKey`
       - `generate() -> Self` -- creates new random key pair using OsRng
       - `load_or_create(config_dir: &Path) -> Result<Self, FluxError>` -- loads from `identity.json` in config dir, or generates and saves if not exists. Store format: `{ "secret_key": "base64", "public_key": "base64" }`
       - `public_key_base64(&self) -> String` -- base64-encoded public key for display
       - `fingerprint(&self) -> String` -- first 16 chars of base64 public key as short fingerprint

    2. `EncryptedChannel` struct:
       - Field: `cipher: XChaCha20Poly1305`
       - `initiate() -> (EphemeralSecret, PublicKey)` -- creates ephemeral key pair for key exchange
       - `complete(secret: EphemeralSecret, peer_public: &PublicKey) -> Self` -- completes DH exchange, creates cipher
       - `encrypt(&self, plaintext: &[u8]) -> Result<(Vec<u8>, [u8; 24]), FluxError>` -- encrypts with random nonce, returns (ciphertext, nonce)
       - `decrypt(&self, ciphertext: &[u8], nonce: &[u8; 24]) -> Result<Vec<u8>, FluxError>` -- decrypts

    Use `x25519_dalek::StaticSecret` (not EphemeralSecret) for DeviceIdentity since it needs persistence. Use `EphemeralSecret` for per-session key exchange in EncryptedChannel.

    Use `use chacha20poly1305::aead::OsRng;` for all RNG operations.

    Create `src/security/trust.rs` with:

    1. `TrustStatus` enum: `Trusted`, `Unknown`, `KeyChanged`

    2. `TrustedDevice` struct (Serialize, Deserialize, Clone):
       - `public_key: String` (base64-encoded)
       - `first_seen: chrono::DateTime<chrono::Utc>`
       - `last_seen: chrono::DateTime<chrono::Utc>`
       - `friendly_name: String`

    3. `TrustStore` struct:
       - `devices: BTreeMap<String, TrustedDevice>`
       - `path: PathBuf` (store file location)
       - `load(config_dir: &Path) -> Result<Self, FluxError>` -- loads from trusted_devices.json, returns empty if not exists
       - `save(&self) -> Result<(), FluxError>` -- atomic write (write .tmp, rename)
       - `is_trusted(&self, device_name: &str, public_key_b64: &str) -> TrustStatus`
       - `add_device(&mut self, name: String, public_key: String, friendly_name: String)` -- adds/updates device with current timestamp
       - `remove_device(&mut self, name: &str) -> bool` -- removes device, returns true if found
       - `list_devices(&self) -> Vec<(&String, &TrustedDevice)>` -- returns all devices sorted by name

    Add `mod security;` to `src/main.rs` module declarations (after `mod queue;`).

    Write unit tests in both crypto.rs and trust.rs:
    - crypto: test key generation, encrypt/decrypt round-trip, different keys produce different ciphertext
    - trust: test load empty store, add/remove device, is_trusted returns correct status, KeyChanged detection
  </action>
  <verify>
    `cargo test security` passes all unit tests. `cargo check` passes. The security module compiles and is accessible from main.rs.
  </verify>
  <done>
    DeviceIdentity can generate/load/save key pairs. EncryptedChannel performs X25519 key exchange and XChaCha20-Poly1305 encrypt/decrypt. TrustStore manages trusted devices with TOFU verification. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` -- all dependencies resolve, no compile errors
2. `cargo test security` -- all security module unit tests pass
3. `cargo test error` -- existing error tests still pass
4. New FluxError variants have Display and suggestion implementations
</verification>

<success_criteria>
- All Phase 5 dependencies added to Cargo.toml and resolve correctly
- EncryptedChannel encrypts and decrypts data chunks successfully
- DeviceIdentity generates, saves, and loads persistent key pairs
- TrustStore manages trusted devices with Trusted/Unknown/KeyChanged status
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-discovery-security/05-01-SUMMARY.md`
</output>
