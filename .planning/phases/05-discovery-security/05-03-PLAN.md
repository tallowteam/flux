---
phase: 05-discovery-security
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/net/sender.rs
  - src/net/receiver.rs
  - src/net/mod.rs
  - src/cli/args.rs
  - src/main.rs
  - tests/phase5_integration.rs
autonomous: true
requirements:
  - DISC-03
  - SEC-01
  - SEC-02
  - SEC-03
  - CLI-03

must_haves:
  truths:
    - "User can run `flux discover` and see a list of Flux devices on the LAN with friendly names"
    - "User can run `flux receive` to start listening for incoming transfers with mDNS registration"
    - "User can run `flux send file.txt @devicename` to send a file to a discovered device"
    - "User can use `--encrypt` flag on send/receive for end-to-end encrypted transfers"
    - "User can run `flux trust list` to see trusted devices and `flux trust rm` to remove them"
    - "Trust-on-first-use works: first encrypted connection prompts, subsequent connections auto-verify"
  artifacts:
    - path: "src/net/sender.rs"
      provides: "TCP client for sending files to Flux receivers"
      exports: ["send_file"]
    - path: "src/net/receiver.rs"
      provides: "TCP server for receiving files from Flux senders"
      exports: ["start_receiver"]
    - path: "src/cli/args.rs"
      provides: "CLI definitions for Send, Receive, Discover, Trust commands"
      contains: "Commands::Send"
    - path: "src/main.rs"
      provides: "Command dispatch for all new subcommands"
      contains: "Commands::Discover"
    - path: "tests/phase5_integration.rs"
      provides: "Integration tests for Phase 5 CLI commands"
      min_lines: 50
  key_links:
    - from: "src/net/sender.rs"
      to: "src/net/protocol.rs"
      via: "FluxMessage encode/decode over Framed TCP"
      pattern: "encode_message.*FluxMessage"
    - from: "src/net/receiver.rs"
      to: "src/security/crypto.rs"
      via: "EncryptedChannel for decrypting received data"
      pattern: "EncryptedChannel"
    - from: "src/main.rs"
      to: "src/net/sender.rs"
      via: "Commands::Send dispatch"
      pattern: "Commands::Send"
    - from: "src/main.rs"
      to: "src/discovery/mdns.rs"
      via: "Commands::Discover dispatch"
      pattern: "discover_flux_devices"
---

<objective>
Implement the send/receive file transfer protocol, CLI commands for all Phase 5 features (discover, send, receive, trust), main.rs dispatch, and integration tests.

Purpose: This is the integration plan that wires Plans 01 and 02 together into working CLI commands. After this plan, all Phase 5 success criteria are met: users can discover devices, send/receive files, use encryption, and manage trusted devices.
Output: Working discover, send, receive, trust CLI commands with integration tests.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-discovery-security/05-RESEARCH.md
@.planning/phases/05-discovery-security/05-01-SUMMARY.md
@.planning/phases/05-discovery-security/05-02-SUMMARY.md

Key integration notes from research:
- Use Runtime::new() locally for send/receive commands (do NOT convert main to #[tokio::main])
- The existing main() is synchronous; create tokio runtime only for commands that need async TCP
- Sender connects via TCP, performs handshake, sends FileHeader then DataChunks, waits for TransferComplete
- Receiver binds TCP, registers mDNS, accepts connections, receives files
- @devicename syntax: resolve device name via mDNS discovery, then connect to its IP:port
- Encryption is per-session: ephemeral key exchange, encrypt DataChunk.data, include nonce
- TOFU: on first encrypted connection, display fingerprint, prompt for acceptance. On subsequent, verify stored key.
- LengthDelimitedCodec from tokio-util wraps TcpStream for message framing
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement net sender and receiver</name>
  <files>
    src/net/sender.rs
    src/net/receiver.rs
    src/net/mod.rs
  </files>
  <action>
    Update `src/net/mod.rs` to add: `pub mod sender; pub mod receiver;`

    Create `src/net/sender.rs` with:

    1. `pub async fn send_file(host: &str, port: u16, file_path: &Path, encrypt: bool, device_name: &str) -> Result<(), FluxError>`:
       - Open TCP connection to host:port
       - Wrap with Framed + LengthDelimitedCodec (max_frame_length = MAX_FRAME_SIZE)
       - Send Handshake message with PROTOCOL_VERSION, device_name, and optional public key (if encrypt=true, generate ephemeral keypair)
       - Wait for HandshakeAck. If rejected, return TransferError with reason.
       - If encrypting: complete key exchange with peer's public key to create EncryptedChannel
       - Read file metadata (size from std::fs::metadata). Send FileHeader with filename, size, encrypted flag.
       - Read file in CHUNK_SIZE chunks (256KB). For each chunk:
         - If encrypted: encrypt chunk data, include nonce in DataChunk
         - If not encrypted: send raw data in DataChunk, nonce = None
         - Send DataChunk with offset tracking
       - Wait for TransferComplete ack from receiver
       - Print transfer summary to stderr (filename, bytes, duration)

    2. `pub fn resolve_device_target(target: &str) -> Result<(String, u16), FluxError>`:
       - If target starts with '@': strip '@', run discover_flux_devices(3) to find device by name (case-insensitive prefix match). Return (host, port). Error if not found.
       - If target contains ':': parse as host:port
       - Otherwise: use target as host with DEFAULT_PORT
       - Map errors to FluxError::TransferError

    3. Top-level sync wrapper: `pub fn send_file_sync(target: &str, file_path: &Path, encrypt: bool, device_name: &str) -> Result<(), FluxError>`:
       - Resolve target to (host, port) via resolve_device_target
       - Create tokio Runtime::new()
       - Block on send_file(host, port, file_path, encrypt, device_name)
       - This is what main.rs calls

    Create `src/net/receiver.rs` with:

    1. `pub async fn start_receiver(port: u16, output_dir: &Path, encrypt: bool, device_name: &str, config_dir: &Path) -> Result<(), FluxError>`:
       - Bind TcpListener on 0.0.0.0:port. If bind fails, suggest --port flag in error.
       - Register mDNS service with register_flux_service (pass public key from DeviceIdentity if encrypt=true)
       - Print "Listening on port {port}..." and "Device name: {device_name}" to stderr
       - Accept loop: for each connection, spawn tokio::spawn(handle_connection(...))
       - handle_connection is the per-peer handler (see below)

    2. `async fn handle_connection(stream: TcpStream, output_dir: PathBuf, encrypt: bool, config_dir: PathBuf)`:
       - Wrap with Framed + LengthDelimitedCodec
       - Read Handshake. Verify version compatibility.
       - If encrypt requested:
         - Generate ephemeral keypair, send HandshakeAck with accepted=true and our public key
         - Create EncryptedChannel with peer's public key
         - TOFU check: load TrustStore, check peer's identity key (from Handshake public_key)
           - Unknown: print warning with fingerprint, auto-accept for v1 (future: prompt), add to trust store
           - Trusted: print "Verified: {device_name}" to stderr
           - KeyChanged: print SSH-style WARNING to stderr, reject connection (send HandshakeAck rejected)
       - If not encrypting: send HandshakeAck with accepted=true, no key
       - Read FileHeader. Create output file at output_dir/filename.
         - If file exists, auto-rename with _1, _2 suffix (reuse find_unique_name pattern from config if accessible, or simple implementation)
       - Read DataChunks in loop until all bytes received:
         - If encrypted: decrypt each chunk using EncryptedChannel
         - Write decrypted/raw data to output file at correct offset
         - Track bytes received
       - Send TransferComplete with bytes_received
       - Print "Received: {filename} ({size})" to stderr

    3. Top-level sync wrapper: `pub fn start_receiver_sync(port: u16, output_dir: &Path, encrypt: bool, device_name: &str) -> Result<(), FluxError>`:
       - Load config_dir via flux_config_dir()
       - Create tokio Runtime::new()
       - Block on start_receiver(port, output_dir, encrypt, device_name, &config_dir)

    Use `futures::SinkExt` for sending frames and `futures::StreamExt` for receiving frames on the Framed stream.

    For sending encoded messages: `framed.send(Bytes::from(encode_message(&msg)?)).await`
    For receiving: `framed.next().await` -> decode_message on the bytes.

    IMPORTANT: main() stays sync. Only send_file and start_receiver are async internally.
  </action>
  <verify>
    `cargo check` passes. sender.rs and receiver.rs compile with async functions. Sync wrappers use Runtime::new() correctly.
  </verify>
  <done>
    sender.rs can connect to a peer, perform handshake, optionally encrypt, and send a file in chunks. receiver.rs can listen, accept connections, receive files, and handle encryption. Both integrate with discovery and security modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI commands and main.rs dispatch</name>
  <files>
    src/cli/args.rs
    src/main.rs
  </files>
  <action>
    Add new command variants to `Commands` enum in `src/cli/args.rs`:

    ```rust
    /// Discover Flux devices on the local network
    Discover(DiscoverArgs),

    /// Send a file to another Flux device
    Send(SendArgs),

    /// Receive files from other Flux devices
    Receive(ReceiveArgs),

    /// Manage trusted devices
    Trust(TrustArgs),
    ```

    Add argument structs:

    ```rust
    #[derive(clap::Args, Debug)]
    pub struct DiscoverArgs {
        /// Discovery timeout in seconds
        #[arg(short, long, default_value = "5")]
        pub timeout: u64,
    }

    #[derive(clap::Args, Debug)]
    pub struct SendArgs {
        /// File to send
        pub file: String,

        /// Target device (@devicename, host:port, or IP)
        pub target: String,

        /// Enable end-to-end encryption
        #[arg(long)]
        pub encrypt: bool,

        /// Device name to identify as
        #[arg(long)]
        pub name: Option<String>,
    }

    #[derive(clap::Args, Debug)]
    pub struct ReceiveArgs {
        /// Directory to save received files (default: current directory)
        #[arg(short, long, default_value = ".")]
        pub output: String,

        /// Port to listen on
        #[arg(short, long, default_value = "9741")]
        pub port: u16,

        /// Enable end-to-end encryption (require encrypted connections)
        #[arg(long)]
        pub encrypt: bool,

        /// Device name to advertise
        #[arg(long)]
        pub name: Option<String>,
    }

    #[derive(clap::Args, Debug)]
    pub struct TrustArgs {
        #[command(subcommand)]
        pub action: Option<TrustAction>,
    }

    #[derive(Subcommand, Debug)]
    pub enum TrustAction {
        /// List trusted devices
        List,
        /// Remove a trusted device
        Rm(TrustRmArgs),
    }

    #[derive(clap::Args, Debug)]
    pub struct TrustRmArgs {
        /// Device name to remove from trust store
        pub name: String,
    }
    ```

    Add command dispatch to `run()` in `src/main.rs`:

    **Commands::Discover:**
    - Call `discovery::mdns::discover_flux_devices(args.timeout)`
    - If no devices found: print "No Flux devices found on the local network" to stderr
    - If devices found: print table to stdout with columns: NAME, HOST, PORT, VERSION
    - Format: fixed-width columns similar to queue list

    **Commands::Send:**
    - Resolve device name for display (strip @ prefix if present)
    - Get device_name from args.name or gethostname()
    - Validate file exists (return SourceNotFound if not)
    - Call `net::sender::send_file_sync(&args.target, Path::new(&args.file), args.encrypt, &device_name)`
    - Print success message to stderr

    **Commands::Receive:**
    - Get device_name from args.name or gethostname()
    - Validate output directory exists (create if not)
    - Call `net::receiver::start_receiver_sync(args.port, Path::new(&args.output), args.encrypt, &device_name)`
    - This blocks until Ctrl+C (the receiver runs indefinitely)

    **Commands::Trust:**
    - Default action (None) -> List
    - List: load TrustStore from config dir, print table: NAME, FINGERPRINT, FIRST_SEEN, LAST_SEEN
    - Rm: load TrustStore, remove device, save, print confirmation

    Add necessary use statements at the top of main.rs.
  </action>
  <verify>
    `cargo check` passes. `cargo build` succeeds. `flux discover --help`, `flux send --help`, `flux receive --help`, `flux trust --help` all show correct usage.
  </verify>
  <done>
    All four new CLI commands (discover, send, receive, trust) are defined in args.rs and dispatched in main.rs. Help text is correct. Commands connect to underlying discovery, net, and security modules.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for Phase 5 features</name>
  <files>
    tests/phase5_integration.rs
  </files>
  <action>
    Create `tests/phase5_integration.rs` with integration tests using assert_cmd and tempfile (matching existing test patterns from Phases 1-4).

    Tests to include:

    1. **test_discover_help** -- `flux discover --help` exits 0, output contains "Discover" and "--timeout"

    2. **test_send_help** -- `flux send --help` exits 0, output contains "Send" and "--encrypt"

    3. **test_receive_help** -- `flux receive --help` exits 0, output contains "Receive" and "--port"

    4. **test_trust_help** -- `flux trust --help` exits 0, output contains "Trust"

    5. **test_trust_list_empty** -- `flux trust list` with empty config dir (via FLUX_CONFIG_DIR env var to temp dir) shows "No trusted devices" or empty table

    6. **test_send_missing_file** -- `flux send nonexistent.txt @device` fails with error about source not found

    7. **test_discover_timeout** -- `flux discover --timeout 1` completes within a few seconds (may find 0 devices -- that's OK, verify it doesn't crash). NOTE: This test does real mDNS browsing. On CI without multicast, it may return empty. The test validates the command runs without error/panic.

    8. **test_send_receive_loopback** -- This is the key integration test:
       - Create a temp directory for output
       - Create a test file with known content (1KB of "Hello Flux\n" repeated)
       - Start `flux receive --port 0 --output <tempdir>` in a background thread/process (use port 0 for OS-assigned port -- if the receiver doesn't support port 0 cleanly, use a high random port like 19741 + random offset)
       - Wait briefly for receiver to start
       - Run `flux send <testfile> 127.0.0.1:<port>`
       - Verify the file appears in tempdir with correct content
       - Mark with `#[ignore]` if it requires network setup that's unreliable in CI

    9. **test_send_receive_encrypted** -- Same as above but with `--encrypt` flag on both send and receive. Mark `#[ignore]` if unreliable.

    Use the test isolation pattern from Phase 4: set FLUX_CONFIG_DIR and FLUX_DATA_DIR env vars to temp directories.

    NOTE: The loopback send/receive tests may be tricky to get right in a test harness (timing, port binding, process management). If they're too complex to make reliable, mark them `#[ignore]` with a comment explaining they're for manual testing. Prioritize the help/error tests that always work.
  </action>
  <verify>
    `cargo test phase5` -- non-ignored tests pass. Help and error handling tests are reliable. Loopback tests work or are appropriately marked #[ignore].
  </verify>
  <done>
    Integration tests verify all Phase 5 CLI commands exist with correct help text. Error handling works for missing files. Trust commands work with isolated config. Loopback send/receive tests validate end-to-end transfer (may be #[ignore] for CI).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full project builds successfully
2. `cargo test` -- all tests pass (including Phases 1-4)
3. `flux discover --timeout 2` -- runs without crash, shows table or "no devices"
4. `flux trust list` -- shows empty trust store or trusted devices
5. `flux send --help` / `flux receive --help` -- correct usage displayed
6. Manual test: start `flux receive` in one terminal, `flux send testfile.txt 127.0.0.1:9741` in another -- file transfers correctly
</verification>

<success_criteria>
- `flux discover` shows Flux devices on LAN with friendly names (or "no devices" message)
- `flux send file.txt @devicename` resolves device via mDNS and sends file over TCP
- `flux receive` listens for connections, registers mDNS service, receives files
- `--encrypt` flag enables X25519 key exchange and XChaCha20-Poly1305 encryption
- `flux trust list` shows trusted devices, `flux trust rm` removes them
- TOFU: first connection with encryption stores peer key, subsequent connections verify it
- All existing Phase 1-4 tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-discovery-security/05-03-SUMMARY.md`
</output>
