---
phase: 07-sync-mode
plan: 02
type: execute
wave: 2
depends_on:
  - 07-01
files_modified:
  - src/sync/mod.rs
  - src/sync/watch.rs
  - src/sync/schedule.rs
  - tests/sync_tests.rs
autonomous: true
requirements:
  - SYNC-03
  - SYNC-04

must_haves:
  truths:
    - "User can enable watch mode with `flux sync --watch source/ dest/` and changes are synced continuously"
    - "Watch mode detects new/modified/deleted files in source and re-syncs automatically"
    - "Watch mode can be stopped with Ctrl+C"
    - "User can schedule recurring syncs with `flux sync --schedule '0 */5 * * * *' source/ dest/`"
    - "Schedule mode parses cron expressions and runs sync at the specified times"
    - "Invalid cron expressions produce a clear error message"
    - "--watch and --schedule are mutually exclusive (error if both provided)"
  artifacts:
    - path: "src/sync/watch.rs"
      provides: "Filesystem watch mode using notify-debouncer-full"
      contains: "watch_and_sync"
    - path: "src/sync/schedule.rs"
      provides: "Cron-based recurring sync using cron crate + tokio"
      contains: "scheduled_sync"
  key_links:
    - from: "src/sync/mod.rs"
      to: "src/sync/watch.rs"
      via: "execute_sync dispatches to watch_and_sync when --watch is set"
      pattern: "watch::watch_and_sync"
    - from: "src/sync/mod.rs"
      to: "src/sync/schedule.rs"
      via: "execute_sync dispatches to scheduled_sync when --schedule is set"
      pattern: "schedule::scheduled_sync"
    - from: "src/sync/watch.rs"
      to: "src/sync/engine.rs"
      via: "On filesystem events, re-runs compute_sync_plan + execute_sync_plan"
      pattern: "compute_sync_plan"
    - from: "src/sync/schedule.rs"
      to: "src/sync/engine.rs"
      via: "On each cron tick, runs compute_sync_plan + execute_sync_plan"
      pattern: "compute_sync_plan"
---

<objective>
Add watch mode (continuous filesystem monitoring) and schedule mode (cron-based recurring sync) to the sync engine.

Purpose: Watch mode enables real-time development workflows where changes are automatically mirrored. Schedule mode enables periodic batch synchronization for backup/archival use cases. Both wrap the existing compute_sync_plan + execute_sync_plan core from Plan 01.

Output: Working `flux sync --watch source/ dest/` and `flux sync --schedule "0 */5 * * * *" source/ dest/` with proper event handling, debouncing, and Ctrl+C graceful shutdown.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-sync-mode/07-RESEARCH.md
@.planning/phases/07-sync-mode/07-01-SUMMARY.md
@src/sync/mod.rs
@src/sync/engine.rs
@src/sync/plan.rs
@src/cli/args.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement watch mode with notify-debouncer-full</name>
  <files>
    src/sync/watch.rs
    src/sync/mod.rs
  </files>
  <action>
Create `src/sync/watch.rs` with filesystem watch mode:

**watch_and_sync function:**
```
pub fn watch_and_sync(
    source: &Path,
    dest: &Path,
    filter: &TransferFilter,
    delete_orphans: bool,
    quiet: bool,
    verify: bool,
) -> Result<(), FluxError>
```

Implementation:
1. Create a `std::sync::mpsc::channel()` for debounced events
2. Create a debouncer with `notify_debouncer_full::new_debouncer(Duration::from_secs(2), None, callback)` where callback sends events via the channel. Map the `notify::Error` to `FluxError::SyncError`.
3. Start watching the source directory with `debouncer.watch(source, notify::RecursiveMode::Recursive)`. Map errors to `FluxError::SyncError`.
4. Print startup message to stderr: `"Watching {source} for changes... (press Ctrl+C to stop)"`
5. Do an initial sync immediately (compute plan + execute if changes exist)
6. Set up Ctrl+C handling using `std::sync::Arc<std::sync::atomic::AtomicBool>` with a ctrlc handler OR use `ctrlc` crate. Since tokio is available, prefer `std::sync::atomic::AtomicBool` with a simple signal check approach: create an `Arc<AtomicBool>` called `running`, set to `true`. Register a ctrlc handler that sets it to `false`. Check `running.load(Ordering::Relaxed)` in the loop.
   - Note: Since `ctrlc` is not in Cargo.toml, use the `ctrlc` crate (add to Cargo.toml under `# Sync (Phase 7)` section: `ctrlc = "3.4"`) OR handle Ctrl+C by catching the channel disconnection when the process is killed. Simpler approach: just use the channel recv with a timeout, and let the natural SIGINT/Ctrl+C kill the process. The debouncer's Drop will clean up.
   - **Preferred approach:** Use `std::sync::mpsc::Receiver::recv_timeout(Duration::from_millis(500))` in a loop. This allows natural Ctrl+C handling (process exits). On recv_timeout Err(Timeout), just continue the loop. On recv_timeout Err(Disconnected), break. On Ok, process the events.
7. Event loop:
   - `recv_timeout(Duration::from_millis(500))` on the channel
   - On `Ok(Ok(events))`: print `"Changes detected, syncing..."` to stderr, then compute_sync_plan + execute_sync_plan if plan has_changes()
   - On `Ok(Err(errors))`: log warnings with `tracing::warn!` for each error
   - On `Err(RecvTimeoutError::Timeout)`: continue (allows checking for shutdown)
   - On `Err(RecvTimeoutError::Disconnected)`: break

**Update src/sync/mod.rs:**
- Add `pub mod watch;`
- In `execute_sync()`, before the normal sync path, add dispatch:
  - If `args.watch`: call `watch::watch_and_sync(source, dest, &filter, args.delete, quiet, args.verify)` and return
  - If `args.schedule.is_some()`: call `schedule::scheduled_sync(...)` and return (placeholder for Task 2)

Unit tests in watch.rs:
- Testing watch mode directly is difficult (requires filesystem events). Add a note that this is covered by integration tests. However, test the debouncer creation and basic setup in a unit test that creates and immediately drops a watcher (smoke test).
  </action>
  <verify>
    `cargo check` compiles. `cargo test --lib -- sync::watch` passes.
  </verify>
  <done>Watch mode works: detects filesystem changes via notify, debounces for 2 seconds, re-syncs on each batch of changes. Initial sync on startup. Graceful handling of watch errors.</done>
</task>

<task type="auto">
  <name>Task 2: Implement schedule mode with cron parsing and tokio sleep loop</name>
  <files>
    src/sync/schedule.rs
    src/sync/mod.rs
  </files>
  <action>
Create `src/sync/schedule.rs` with cron-based scheduling:

**scheduled_sync function:**
```
pub fn scheduled_sync(
    cron_expr: &str,
    source: &Path,
    dest: &Path,
    filter: &TransferFilter,
    delete_orphans: bool,
    quiet: bool,
    verify: bool,
) -> Result<(), FluxError>
```

Implementation:
1. Parse the cron expression using `cron::Schedule::from_str(cron_expr)`. Map parse errors to `FluxError::SyncError(format!("Invalid cron expression '{}': {}", cron_expr, e))`.
2. Print startup info to stderr: `"Scheduled sync: {source} -> {dest}"`, `"Cron: {cron_expr}"`
3. Note: The `cron` crate expects 6-field or 7-field cron expressions (sec min hour day month dow [year]). Standard 5-field expressions (min hour day month dow) need a leading "0 " prepended. Detect if the expression has 5 fields and auto-prepend "0 " for user convenience. This way `flux sync --schedule "*/5 * * * *"` works (every 5 minutes).
4. Create a tokio Runtime (`tokio::runtime::Runtime::new()`) and block on an async loop:
   - `loop`:
     - Get next fire time: `schedule.upcoming(chrono::Utc).next()`
     - If None, return error (no upcoming times)
     - Calculate duration until next fire: `(next - chrono::Utc::now()).to_std().unwrap_or(Duration::from_secs(1))`
     - Print `"Next sync at: {next}"` to stderr
     - `tokio::time::sleep(duration).await`
     - Run sync: compute_sync_plan + execute_sync_plan
     - Print result summary
5. The loop runs forever until Ctrl+C kills the process (natural behavior for a scheduler).

**Update src/sync/mod.rs:**
- Add `pub mod schedule;`
- Wire the schedule dispatch: `if let Some(ref cron_expr) = args.schedule { return schedule::scheduled_sync(cron_expr, ...) }`

Unit tests in schedule.rs:
- `test_cron_expression_parsing_valid` - "0 */5 * * * *" parses without error
- `test_cron_expression_parsing_invalid` - "not a cron" returns SyncError
- `test_five_field_cron_auto_expand` - test that 5-field expressions get "0 " prepended (if implementing auto-expansion, test the helper function)
- `test_next_fire_time_computed` - parse a cron, call upcoming().next(), assert it's in the future
  </action>
  <verify>
    `cargo test --lib -- sync::schedule` passes all tests. `cargo check` compiles.
  </verify>
  <done>Schedule mode parses cron expressions, calculates next fire time, sleeps until then, runs sync, repeats. Invalid cron expressions produce clear error. 5-field cron auto-expansion works.</done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for watch, schedule, and end-to-end sync polish</name>
  <files>
    tests/sync_tests.rs
  </files>
  <action>
Add integration tests to the existing `tests/sync_tests.rs` (created in Plan 01):

**Watch mode tests:**
- `test_sync_watch_initial_sync`: Start `flux sync --watch source/ dest/` in a background thread with a timeout. Assert that the initial sync happens (files appear in dest within 5 seconds). Kill the process after verification.
  - Implementation: Use `std::process::Command::new(cargo_bin("flux"))` with `.spawn()` instead of `.assert()`. Wait briefly, check dest files, then kill the child process.
- `test_sync_watch_schedule_mutually_exclusive`: Run `flux sync --watch --schedule "0 * * * * *" source/ dest/`. Assert exit code is non-zero and stderr contains error about mutually exclusive options. (This may already exist from Plan 01 -- if so, skip.)

**Schedule mode tests:**
- `test_sync_schedule_invalid_cron`: Run `flux sync --schedule "not valid" source/ dest/`. Assert error output mentions "Invalid cron expression".
- `test_sync_schedule_prints_next_time`: Start `flux sync --schedule "0 0 */1 * * *" source/ dest/` as a spawned process. Read stderr for a few seconds, assert it contains "Next sync at:". Kill process.

**Additional edge case integration tests:**
- `test_sync_nested_directories`: Create source with nested subdirectories (a/b/c/file.txt). Sync. Assert nested structure preserved in dest.
- `test_sync_verify_flag`: Run `flux sync --verify source/ dest/`. Assert files are copied and no checksum errors (files match).
- `test_sync_force_empty_source_delete`: Create empty source, dest with files. Run `flux sync --delete --force source/ dest/`. Assert dest files are deleted (force overrides safety check).

**Test patterns:**
- Use `tempfile::TempDir` for all directories
- For background process tests, use `std::process::Command::spawn()` + sleep + kill pattern
- Keep timeouts short (2-5 seconds) to avoid slow test suite
- Use `cargo_bin("flux")` from assert_cmd for binary path
  </action>
  <verify>
    `cargo test --test sync_tests` passes all tests (both Plan 01 and Plan 02 tests). Full test suite: `cargo test` passes.
  </verify>
  <done>Complete integration test coverage: watch mode initial sync, schedule mode cron parsing, nested directories, --verify flag, --force override, mutually exclusive flag validation. All ~15+ sync tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --lib -- sync::` - all unit tests pass (plan, engine, watch, schedule)
2. `cargo test --test sync_tests` - all integration tests pass
3. `cargo test` - full test suite passes (all ~400+ tests)
4. Manual test: `flux sync --watch source/ dest/` - create a file in source, verify it appears in dest within ~3 seconds
5. Manual test: `flux sync --schedule "*/1 * * * *" source/ dest/` - verify "Next sync at:" message printed, sync runs on schedule
</verification>

<success_criteria>
- `flux sync --watch source/ dest/` monitors source and auto-syncs on changes with 2-second debounce
- `flux sync --schedule "*/5 * * * *" source/ dest/` runs sync every 5 minutes
- Watch mode performs initial sync on startup
- Invalid cron expressions produce clear error messages
- --watch and --schedule are mutually exclusive
- All tests pass (unit + integration)
</success_criteria>

<output>
After completion, create `.planning/phases/07-sync-mode/07-02-SUMMARY.md`
</output>
