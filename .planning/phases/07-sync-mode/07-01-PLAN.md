---
phase: 07-sync-mode
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/error.rs
  - src/cli/args.rs
  - src/main.rs
  - src/sync/mod.rs
  - src/sync/plan.rs
  - src/sync/engine.rs
autonomous: true
requirements:
  - SYNC-01
  - SYNC-02

must_haves:
  truths:
    - "User can sync directories with `flux sync source/ dest/` and files are mirrored"
    - "New files in source are copied to dest"
    - "Changed files (newer mtime or different size) in source are updated in dest"
    - "Files identical in both directories are skipped"
    - "User can preview sync changes with `flux sync --dry-run` without any files being modified"
    - "User can delete orphaned dest files with `--delete` flag"
    - "User can filter files with `--exclude` and `--include` glob patterns"
  artifacts:
    - path: "src/sync/plan.rs"
      provides: "SyncAction enum, SyncPlan struct, display formatting"
      contains: "SyncAction"
    - path: "src/sync/engine.rs"
      provides: "compute_sync_plan and execute_sync_plan functions"
      exports: ["compute_sync_plan", "execute_sync_plan"]
    - path: "src/sync/mod.rs"
      provides: "Public API: execute_sync() dispatcher"
      exports: ["execute_sync"]
  key_links:
    - from: "src/main.rs"
      to: "src/sync/mod.rs"
      via: "Commands::Sync dispatch to sync::execute_sync()"
      pattern: "sync::execute_sync"
    - from: "src/sync/engine.rs"
      to: "src/transfer/copy.rs"
      via: "Reuses copy_file_with_progress for file operations"
      pattern: "copy_file_with_progress"
    - from: "src/sync/engine.rs"
      to: "src/transfer/filter.rs"
      via: "Reuses TransferFilter for include/exclude glob patterns"
      pattern: "TransferFilter"
---

<objective>
Build the core sync engine with diff-then-execute architecture and dry-run support.

Purpose: Enable one-way directory mirroring by computing a diff plan (SyncAction list) between source and dest trees, then executing it. Dry-run prints the plan without executing. This is the foundation that watch mode and schedule mode wrap around.

Output: Working `flux sync source/ dest/` with mtime+size comparison, `--dry-run` preview, `--delete` orphan removal, `--exclude`/`--include` filtering, progress display.
</objective>

<execution_context>
@C:/Users/trima/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/trima/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-sync-mode/07-RESEARCH.md
@src/error.rs
@src/cli/args.rs
@src/main.rs
@src/transfer/mod.rs
@src/transfer/copy.rs
@src/transfer/filter.rs
@src/progress/bar.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies, extend SyncArgs, add SyncError variant</name>
  <files>
    Cargo.toml
    src/cli/args.rs
    src/error.rs
  </files>
  <action>
1. Add dependencies to Cargo.toml under a `# Sync (Phase 7)` comment:
   - `notify = "8.2"` (filesystem watching - needed in Plan 02 but add now for clean dependency management)
   - `notify-debouncer-full = "0.7"` (event debouncing - needed in Plan 02)
   - `cron = "0.15"` (cron parsing - needed in Plan 02)

2. Extend the existing `SyncArgs` struct in `src/cli/args.rs` to add all sync-related flags. The existing skeleton has `source`, `dest`, and `dry_run`. Add:
   - `#[arg(long)] pub delete: bool` - Delete files in dest that don't exist in source
   - `#[arg(long)] pub watch: bool` - Watch source for changes and sync continuously
   - `#[arg(long)] pub schedule: Option<String>` - Schedule recurring syncs with cron expression
   - `#[arg(long, action = clap::ArgAction::Append)] pub exclude: Vec<String>` - Exclude glob patterns
   - `#[arg(long, action = clap::ArgAction::Append)] pub include: Vec<String>` - Include glob patterns
   - `#[arg(long)] pub verify: bool` - Verify integrity with BLAKE3 after sync
   - `#[arg(long)] pub force: bool` - Force sync even when source is empty (safety override for --delete)

3. Add `SyncError(String)` variant to FluxError enum in `src/error.rs`. Add a suggestion for it in the `suggestion()` method: `"Check that source and destination directories exist and are accessible."`.
  </action>
  <verify>
    `cargo check` compiles without errors. `cargo test --lib -- error::tests` passes. `flux sync --help` shows all new flags.
  </verify>
  <done>SyncArgs has all flags (delete, watch, schedule, exclude, include, verify, force). FluxError::SyncError variant exists. New crate dependencies in Cargo.toml.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SyncAction/SyncPlan types and compute_sync_plan with TDD</name>
  <files>
    src/sync/mod.rs
    src/sync/plan.rs
    src/sync/engine.rs
  </files>
  <action>
Create the `sync` module directory with three files. Add `mod sync;` to `src/main.rs`.

**src/sync/mod.rs:**
- `pub mod plan;` and `pub mod engine;`
- `pub fn execute_sync(args: SyncArgs, quiet: bool) -> Result<(), FluxError>` dispatcher that:
  1. Validates source exists and is a directory
  2. Creates dest directory if it doesn't exist (like `flux cp -r` behavior)
  3. Validates `--watch` and `--schedule` are mutually exclusive (return `SyncError` if both set)
  4. Builds `TransferFilter` from args.exclude/args.include
  5. Calls `compute_sync_plan(source, dest, &filter, args.delete)`
  6. If `args.dry_run`: prints the plan summary and action list, returns Ok
  7. If not dry_run: calls `execute_sync_plan(&plan, quiet, args.verify)`
  8. Prints summary: N files copied, N updated, N deleted, N skipped, total bytes

**src/sync/plan.rs:**
- `SyncAction` enum with variants:
  - `CopyNew { src: PathBuf, dest: PathBuf, size: u64 }` - file only in source
  - `UpdateChanged { src: PathBuf, dest: PathBuf, src_size: u64, dest_size: u64 }` - source newer/different
  - `DeleteOrphan { path: PathBuf, size: u64 }` - file only in dest (when --delete)
  - `Skip { path: PathBuf, reason: &'static str }` - identical files
- `SyncPlan` struct with fields: `actions: Vec<SyncAction>`, `total_copy_bytes: u64`, `files_to_copy: u64`, `files_to_update: u64`, `files_to_delete: u64`, `files_to_skip: u64`
- `SyncPlan::from_actions(actions: Vec<SyncAction>) -> Self` that computes summary counts
- `SyncPlan::has_changes() -> bool` (any action that isn't Skip)
- `impl Display for SyncAction` showing human-readable descriptions like: `  COPY  file.txt (1.2 MB)`, `  UPDATE  readme.md (changed)`, `  DELETE  old.txt`, `  SKIP  same.txt (unchanged)`
- `SyncPlan::print_summary()` showing the plan overview with counts and total bytes

**src/sync/engine.rs:**
- `fn needs_sync(src_meta: &std::fs::Metadata, dest_path: &Path) -> SyncDecision` using mtime+size comparison:
  - Dest doesn't exist -> CopyNew
  - Different size -> Update
  - Source mtime > dest mtime (with 2-second threshold for cross-filesystem tolerance) -> Update
  - Otherwise -> Skip
- `SyncDecision` enum: `CopyNew`, `Update`, `Skip`
- `pub fn compute_sync_plan(source: &Path, dest: &Path, filter: &TransferFilter, delete_orphans: bool) -> Result<SyncPlan, FluxError>`:
  - Phase 1: Walk source with `WalkDir::new(source).follow_links(false)`, filter with TransferFilter, compare each file against dest using `needs_sync`
  - Phase 2: If delete_orphans, walk dest tree and find files not in source, create DeleteOrphan actions
  - Safety check: if delete_orphans and source has 0 transferable files, return `SyncError("Source directory is empty but --delete is set. Use --force to proceed.")`
  - Build SyncPlan from collected actions
- `pub fn execute_sync_plan(plan: &SyncPlan, quiet: bool, verify: bool) -> Result<SyncResult, FluxError>`:
  - Create a progress bar for the overall sync (total files to process)
  - For each CopyNew/UpdateChanged: ensure parent dir exists, copy using `copy_file_with_progress`, optionally verify with `hash_file`
  - For each DeleteOrphan: `std::fs::remove_file(path)`
  - Skip actions are ignored
  - Returns `SyncResult { files_copied, files_updated, files_deleted, files_skipped, bytes_transferred }`

**TDD approach - write tests FIRST in each file, then implement:**

Tests for `plan.rs`:
- `test_sync_plan_from_actions_counts` - verify summary counts computed correctly from mixed action list
- `test_sync_plan_has_changes_true` - plan with CopyNew returns true
- `test_sync_plan_has_changes_false_all_skips` - plan with only Skip returns false
- `test_sync_action_display` - verify human-readable formatting

Tests for `engine.rs`:
- `test_needs_sync_dest_missing` - returns CopyNew when dest doesn't exist
- `test_needs_sync_different_size` - returns Update when sizes differ
- `test_needs_sync_same_file` - returns Skip when mtime and size match
- `test_compute_sync_plan_new_files` - source has files, dest empty, all CopyNew
- `test_compute_sync_plan_mixed` - source has new + existing, correct actions
- `test_compute_sync_plan_delete_orphans` - orphans in dest become DeleteOrphan
- `test_compute_sync_plan_empty_source_delete_safety` - empty source + delete returns error
- `test_execute_sync_plan_copies_files` - actually copies files to dest
- `test_execute_sync_plan_deletes_orphans` - removes orphan files from dest

Use `tempfile::TempDir` for all filesystem tests. Create test files with known content and manipulate mtimes using `filetime` crate if needed (or just create files with different content to ensure size differences).

Note: If `filetime` is not already a dependency, use size differences instead of mtime differences for reliable cross-platform testing. The mtime comparison code path will be covered by the "dest missing" and "different size" tests.
  </action>
  <verify>
    `cargo test --lib -- sync::` passes all tests. `cargo check` compiles cleanly.
  </verify>
  <done>SyncAction/SyncPlan types work correctly. compute_sync_plan diffs source vs dest using mtime+size. execute_sync_plan copies/updates/deletes files. Empty source safety check works. All unit tests pass RED then GREEN.</done>
</task>

<task type="auto">
  <name>Task 3: Wire sync command in main.rs and add integration tests</name>
  <files>
    src/main.rs
    tests/sync_tests.rs
  </files>
  <action>
1. In `src/main.rs`, replace the `Commands::Sync(_args)` stub with:
   ```
   Commands::Sync(args) => {
       sync::execute_sync(args, cli.quiet)
   }
   ```
   Add `use cli::args::SyncArgs;` if not already imported. Ensure `mod sync;` is declared.

2. Create `tests/sync_tests.rs` with integration tests using `assert_cmd::Command::cargo_bin("flux")` and `tempfile::TempDir`:

   - `test_sync_basic_copy`: Create source dir with 3 files, empty dest dir. Run `flux sync source/ dest/`. Assert all 3 files exist in dest with correct content.
   - `test_sync_dry_run_no_changes`: Create source dir with files, empty dest. Run `flux sync --dry-run source/ dest/`. Assert dest is still empty. Assert stderr contains "COPY" action descriptions.
   - `test_sync_skips_unchanged`: Create source and dest with identical files. Run sync. Assert output mentions "skip" or no files copied.
   - `test_sync_updates_changed`: Create source and dest with same file but different content (different size). Run sync. Assert dest file now matches source.
   - `test_sync_delete_orphans`: Create source with file_a, dest with file_a + file_b. Run `flux sync --delete source/ dest/`. Assert file_b removed from dest, file_a remains.
   - `test_sync_exclude_pattern`: Create source with file.txt and file.log. Run `flux sync --exclude "*.log" source/ dest/`. Assert only file.txt in dest.
   - `test_sync_empty_source_delete_safety`: Create empty source, dest with files. Run `flux sync --delete source/ dest/`. Assert error about empty source.
   - `test_sync_creates_dest_directory`: Run sync where dest doesn't exist yet. Assert dest created and files synced.
   - `test_sync_watch_schedule_mutex`: Run `flux sync --watch --schedule "* * * * *" source/ dest/`. Assert error about mutually exclusive flags.
  </action>
  <verify>
    `cargo test --test sync_tests` passes all 9 tests. `flux sync --help` shows correct usage.
  </verify>
  <done>`flux sync source/ dest/` works end-to-end. Dry-run previews without modifying. --delete removes orphans. --exclude filters files. 9 integration tests prove all sync behaviors.</done>
</task>

</tasks>

<verification>
1. `cargo test --lib -- sync::` - all unit tests pass
2. `cargo test --test sync_tests` - all integration tests pass
3. `cargo check` - clean compilation
4. Manual verification: create two directories with mixed files, run `flux sync --dry-run src/ dest/`, confirm preview output, then run `flux sync src/ dest/`, confirm files mirrored
</verification>

<success_criteria>
- `flux sync source/ dest/` mirrors source to dest (new files copied, changed files updated, unchanged skipped)
- `flux sync --dry-run source/ dest/` previews all changes without modifying any files
- `flux sync --delete source/ dest/` removes files in dest not present in source
- `--exclude` and `--include` glob patterns filter which files are synced
- Safety: empty source with --delete refuses without --force
- All tests pass (unit + integration)
</success_criteria>

<output>
After completion, create `.planning/phases/07-sync-mode/07-01-SUMMARY.md`
</output>
