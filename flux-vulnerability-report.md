# Flux Security Vulnerability Report

**Date:** 2026-02-17
**Scope:** Full codebase — P2P network layer, cryptographic module, trust store, file I/O
**Basis:** audit-context.md (3-phase ultra-granular analysis)

---

## Finding Summary

| # | Title | Severity | Category |
|---|-------|----------|----------|
| 1 | Code-phrase mode lacks authentication binding (no PAKE) | **HIGH** | Crypto Design |
| 2 | Entire file buffered in memory — OOM on both sender and receiver | **HIGH** | Denial of Service |
| 3 | Auto-TOFU without user confirmation enables trust store pollution | **MEDIUM** | Authentication |
| 4 | Silent trust store corruption recovery forces re-TOFU | **MEDIUM** | Data Integrity |
| 5 | TOCTOU + symlink attack in receiver file write path | **MEDIUM** | File System |
| 6 | No sender-side timeouts — malicious peer stalls indefinitely | **MEDIUM** | Denial of Service |
| 7 | `sanitize_filename()` missing Windows reserved name handling | **LOW** | File System |
| 8 | Memory zeroization gaps in identity file I/O | **LOW** | Crypto Hygiene |
| 9 | No Windows ACL on identity.json | **LOW** | Platform |
| 10 | SharedSecret not explicitly zeroized in `EncryptedChannel::complete()` | **LOW** | Crypto Hygiene |
| 11 | Temporary file persistence on error in `DeviceIdentity::save()` | **LOW** | Crypto Hygiene |
| 12 | mDNS first-match-wins race condition | **INFO** | Discovery |
| 13 | Entropy documentation mismatch (37 bits, not 38) | **INFO** | Documentation |

---

## Finding 1: Code-Phrase Mode Lacks Authentication Binding (No PAKE)

**Severity:** HIGH
**Location:** `src/net/codephrase.rs:102`, `src/net/sender.rs:252-340`, `src/net/receiver.rs:497-560`
**Category:** Cryptographic Design Flaw

### Description

The code phrase is used **only** for mDNS discovery (BLAKE3 hash matching). It is NOT used as input to a Password-Authenticated Key Exchange (PAKE). The actual encrypted channel uses ephemeral X25519, which provides confidentiality but **no authentication** — the key exchange has no cryptographic binding to the code phrase.

### Attack Scenario

1. Alice runs `flux send secret.pdf` → generates code `1234-ace-bad-car`
2. Alice tells Bob the code phrase out-of-band
3. Attacker Eve on the same LAN observes the mDNS advertisement containing `code_hash` (BLAKE3 prefix broadcast in cleartext)
4. Eve registers her own mDNS service with the same `code_hash`, or races to TCP connect to Alice's port before Bob
5. Eve completes an unauthenticated X25519 key exchange with Alice
6. Alice encrypts `secret.pdf` with the shared key derived from Eve's ephemeral public key
7. Eve receives the file. Bob gets nothing (or connects afterward and gets a stale transfer)

### Impact

Any attacker on the same LAN can **intercept** code-phrase transfers without knowing the code phrase itself. The code phrase provides zero authentication guarantee — it only aids discovery.

### Recommendation

Integrate a PAKE protocol (e.g., SPAKE2 or CPace) that binds the code phrase to the key exchange. The shared key should be derived from both the DH output AND the code phrase, so only a party who knows the code phrase can complete the handshake.

**Sketch:**
```rust
// In EncryptedChannel::complete(), bind code phrase to KDF:
let kdf_input = [shared.as_bytes(), code_phrase.as_bytes()].concat();
let derived_key = blake3::derive_key(KDF_CONTEXT, &kdf_input);
```

This is a minimum fix. A full PAKE (SPAKE2 via the `spake2` crate) is preferable because it provides mutual authentication and never transmits the password equivalent.

---

## Finding 2: Entire File Buffered in Memory — OOM on Both Sender and Receiver

**Severity:** HIGH
**Location:** `src/net/sender.rs:141` (`fs::read`), `src/net/receiver.rs:355-400` (`Vec<u8>` accumulation)
**Category:** Denial of Service / Resource Exhaustion

### Description

**Sender:** `send_file()` at line 141 calls `std::fs::read(file_path)`, which reads the entire file into a `Vec<u8>`. A 4GB file requires 4GB+ of RAM.

**Receiver:** Pre-allocates `Vec::with_capacity(file_size.min(256MB))` then grows via `extend_from_slice()` as chunks arrive. A malicious sender claiming `file_size = 4GB` causes memory growth up to 4GB.

This contrasts with the local copy path (`transfer/parallel.rs`) which uses chunked I/O and never holds the full file in memory.

### Attack Scenario (Receiver)

1. Attacker connects to a Flux receiver
2. Sends `FileHeader { size: 4_000_000_000, ... }`
3. Streams 256KB data chunks until the receiver OOMs
4. Receiver process crashes

### Attack Scenario (Sender, self-inflicted)

1. User runs `flux send /path/to/huge-video.mkv @device`
2. `fs::read()` attempts to allocate the file's full size
3. System runs out of memory; process killed by OOM killer

### Impact

- Remote attacker can crash any Flux receiver with a single connection
- Local users crash their own machine when sending large files
- No concurrent transfer support possible with this design

### Recommendation

Switch to streaming I/O for the P2P path. Read/write in `CHUNK_SIZE` (256KB) chunks using `tokio::io::AsyncRead`/`AsyncWrite`:

**Sender fix:**
```rust
// Replace fs::read with chunked read
let file = tokio::fs::File::open(file_path).await?;
let mut reader = tokio::io::BufReader::new(file);
let mut hasher = blake3::Hasher::new();
let mut offset = 0u64;
let mut buf = vec![0u8; CHUNK_SIZE];

loop {
    let n = reader.read(&mut buf).await?;
    if n == 0 { break; }
    hasher.update(&buf[..n]);
    // encrypt chunk if needed, then send DataChunk
    offset += n as u64;
}
let checksum = hasher.finalize().to_hex().to_string();
```

**Receiver fix:**
```rust
// Write chunks directly to disk instead of accumulating in Vec
let file = tokio::fs::File::create(&output_path).await?;
let mut writer = tokio::io::BufWriter::new(file);
// In the DataChunk loop:
writer.write_all(&chunk_data).await?;
hasher.update(&chunk_data);
```

---

## Finding 3: Auto-TOFU Without User Confirmation Enables Trust Store Pollution

**Severity:** MEDIUM
**Location:** `src/net/receiver.rs:188-201`
**Category:** Authentication

### Description

When a receiver encounters an unknown device (`TrustStatus::Unknown`), it automatically trusts the device, saves its public key to the trust store, and continues the transfer — all without user confirmation.

```rust
TrustStatus::Unknown => {
    // Auto-trust for v1 (future: interactive prompt)
    eprintln!("Auto-trusting for this session (v1 behavior).");
    trust_store.add_device(peer_device_name.clone(), peer_pub_b64, ...);
    trust_store.save()?;
}
```

### Attack Scenario

1. Attacker on the LAN repeatedly connects to victim's Flux receiver with different device names
2. Each connection auto-trusts and saves to `trusted_devices.json`
3. Trust store fills with attacker-controlled entries
4. When the real sender (e.g., `alice-laptop`) connects later, victim has no way to distinguish it from the attacker's entries
5. Attacker can also use the trusted identity to send malicious files that appear to come from a "trusted" device

### Impact

Untrusted devices gain permanent trusted status without any user awareness. Trust store becomes unreliable as a security boundary.

### Recommendation

Add interactive confirmation for first-time trust. Require explicit `--auto-trust` flag to restore v1 behavior:

```rust
TrustStatus::Unknown => {
    let fingerprint = &peer_pub_b64[..16];
    eprintln!("Unknown device: {} (fingerprint: {}...)", peer_device_name, fingerprint);
    if auto_trust {
        eprintln!("Auto-trusting (--auto-trust enabled).");
        trust_store.add_device(...);
    } else {
        eprint!("Trust this device? [y/N]: ");
        let mut input = String::new();
        std::io::stdin().read_line(&mut input)?;
        if input.trim().eq_ignore_ascii_case("y") {
            trust_store.add_device(...);
        } else {
            // Reject connection
            send_error(&mut framed, "Connection rejected by user").await?;
            return Ok(());
        }
    }
}
```

---

## Finding 4: Silent Trust Store Corruption Recovery Forces Re-TOFU

**Severity:** MEDIUM
**Location:** `src/security/trust.rs:68-81`
**Category:** Data Integrity / Trust Downgrade

### Description

When `trusted_devices.json` fails to parse, `TrustStore::load()` logs a warning and returns an empty store:

```rust
Err(e) => {
    tracing::warn!("Trust store corrupted ({}), starting fresh.", e);
    Ok(Self { devices: BTreeMap::new(), path })
}
```

This means:
1. All previously trusted devices are silently forgotten
2. Subsequent connections trigger the auto-trust path (Finding 3)
3. An attacker who can corrupt the file (e.g., via a race condition, filesystem manipulation, or another vulnerability) forces re-TOFU of all devices

### Impact

An attacker who can write a single byte to `trusted_devices.json` (even just appending a character) can reset all trust relationships. Combined with Finding 3 (auto-trust), this allows full device impersonation.

### Recommendation

Return an error on corruption instead of silently recovering:

```rust
Err(e) => {
    tracing::error!("Trust store corrupted: {}", e);
    Err(FluxError::TrustError(format!(
        "Trust store corrupted ({}). Run 'flux trust reset' to start fresh, \
         or restore from backup.", e
    )))
}
```

Add an explicit `flux trust reset` subcommand for intentional resets.

---

## Finding 5: TOCTOU + Symlink Attack in Receiver File Write Path

**Severity:** MEDIUM
**Location:** `src/net/receiver.rs:840-871` (`find_unique_path`), `src/net/receiver.rs:456` (`fs::write`)
**Category:** File System Race Condition

### Description

`find_unique_path()` uses `path.exists()` to check for file name collisions, then the caller uses `fs::write()` to write the file. Between these two calls, another process or user can:

1. Create a symlink at the target path pointing to a sensitive file (e.g., `~/.ssh/authorized_keys`)
2. `fs::write()` follows the symlink and overwrites the target

### Attack Scenario

1. Attacker has write access to the receiver's output directory
2. Flux receiver determines `output_dir/file.txt` does not exist (line 843)
3. Before `fs::write()` executes, attacker creates symlink: `output_dir/file.txt` → `/home/user/.bashrc`
4. Receiver writes attacker-supplied file content to `/home/user/.bashrc`
5. Next time user opens a shell, attacker's code executes

### Impact

Arbitrary file write via symlink following. On shared systems, this enables privilege escalation if the receiver runs with elevated permissions.

### Recommendation

Use atomic exclusive create to prevent both the TOCTOU race and symlink following:

```rust
use std::fs::OpenOptions;

fn write_file_safely(path: &Path, data: &[u8]) -> Result<(), FluxError> {
    // O_CREAT | O_EXCL: fails if path already exists (including symlinks)
    let mut file = OpenOptions::new()
        .write(true)
        .create_new(true)  // atomic: fails if exists
        .open(path)
        .map_err(|e| FluxError::TransferError(format!("Cannot create {}: {}", path.display(), e)))?;
    file.write_all(data)?;
    Ok(())
}
```

For the unique-path loop, move the collision resolution into the open call itself (retry on `AlreadyExists` error) rather than checking `exists()` first.

---

## Finding 6: No Sender-Side Timeouts — Malicious Peer Stalls Indefinitely

**Severity:** MEDIUM
**Location:** `src/net/sender.rs:75` (HandshakeAck wait), `src/net/sender.rs:206` (TransferComplete wait)
**Category:** Denial of Service

### Description

The sender awaits `framed.next().await` with no timeout when waiting for:
1. `HandshakeAck` from the receiver (line 75)
2. `TransferComplete` from the receiver (line 206)

A malicious receiver can accept the TCP connection, complete the handshake, receive all the file data, and then simply never send `TransferComplete` — keeping the sender blocked forever.

The receiver correctly uses a 30-minute timeout per connection, but the sender has no equivalent protection.

### Impact

- A malicious receiver can permanently stall a Flux sender
- User must manually kill the process
- In automated/scripted usage, this causes a permanent hang

### Recommendation

Wrap network reads in `tokio::time::timeout`:

```rust
use tokio::time::{timeout, Duration};

const HANDSHAKE_TIMEOUT: Duration = Duration::from_secs(30);
const COMPLETION_TIMEOUT: Duration = Duration::from_secs(300); // 5 minutes

// HandshakeAck wait:
let ack_bytes = timeout(HANDSHAKE_TIMEOUT, framed.next())
    .await
    .map_err(|_| FluxError::TransferError("Timed out waiting for handshake response".into()))?
    .ok_or_else(|| FluxError::TransferError("Connection closed during handshake".into()))?
    .map_err(|e| FluxError::TransferError(format!("Handshake read error: {}", e)))?;

// TransferComplete wait:
let complete_bytes = timeout(COMPLETION_TIMEOUT, framed.next())
    .await
    .map_err(|_| FluxError::TransferError("Timed out waiting for transfer confirmation".into()))?
    // ...
```

---

## Finding 7: `sanitize_filename()` Missing Windows Reserved Name Handling

**Severity:** LOW
**Location:** `src/net/receiver.rs:814-829`
**Category:** File System / Platform Compatibility

### Description

`sanitize_filename()` strips path traversal (directory components) and leading dots, but does not block Windows reserved device names: `CON`, `PRN`, `AUX`, `NUL`, `COM1`-`COM9`, `LPT1`-`LPT9`.

On Windows, creating a file named `CON` or `NUL` can cause unexpected behavior or errors — the name resolves to the console or null device instead of a regular file.

### Impact

On Windows receivers, a malicious sender can send files with reserved names, causing I/O errors or writes to device handles. Low severity because Windows will typically return an error rather than silently misbehave, but it denies the transfer.

### Recommendation

```rust
fn sanitize_filename(filename: &str) -> String {
    let name = Path::new(filename)
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_default();
    let name = name.trim_start_matches('.');

    if name.is_empty() {
        return "unnamed".to_string();
    }

    // Block Windows reserved names
    let stem = name.split('.').next().unwrap_or("");
    let reserved = ["CON","PRN","AUX","NUL",
        "COM1","COM2","COM3","COM4","COM5","COM6","COM7","COM8","COM9",
        "LPT1","LPT2","LPT3","LPT4","LPT5","LPT6","LPT7","LPT8","LPT9"];
    if reserved.iter().any(|r| r.eq_ignore_ascii_case(stem)) {
        return format!("_{}", name);
    }

    name.to_string()
}
```

---

## Finding 8: Memory Zeroization Gaps in Identity File I/O

**Severity:** LOW
**Location:** `src/security/crypto.rs:90` (load), `src/security/crypto.rs:140-147` (save)
**Category:** Cryptographic Hygiene

### Description

Three intermediate strings containing the secret key are not zeroized:

1. **`load_or_create` line 90:** `fs::read_to_string()` returns a `String` containing the full JSON with base64 secret key. Never zeroed.
2. **`save` line 140-143:** `IdentityFile` struct contains `secret_key: String` (base64). Never zeroed after serialization.
3. **`save` lines 145-147:** `serde_json::to_string_pretty()` returns a `String` with the serialized secret. Never zeroed.

When these `String`s are dropped, the heap memory is deallocated but NOT overwritten. The secret key remains in memory until the allocator reuses that memory.

### Impact

If the process memory is dumped (e.g., core dump, forensic analysis, or another vulnerability provides memory read access), the secret key can be recovered from freed heap memory. Low severity because it requires a secondary vulnerability.

### Recommendation

Use `zeroize::Zeroizing<String>` wrappers:

```rust
use zeroize::Zeroizing;

// In load_or_create:
let data = Zeroizing::new(fs::read_to_string(&path)?);

// In save:
let file = IdentityFile { secret_key: ... };
let json = Zeroizing::new(serde_json::to_string_pretty(&file)?);
fs::write(&tmp_path, json.as_bytes())?;
// json automatically zeroed on drop
```

---

## Finding 9: No Windows ACL on identity.json

**Severity:** LOW
**Location:** `src/security/crypto.rs:136-165` (`DeviceIdentity::save()`)
**Category:** Platform-Specific Gap

### Description

`save()` sets Unix permissions (`0o600`) on the identity file, but on Windows this code is behind `#[cfg(unix)]` and has no Windows equivalent. On Windows, the identity file is created with default ACLs, which typically means readable by all users on the machine.

### Impact

On multi-user Windows machines, any user can read `identity.json` and extract the X25519 private key, enabling device impersonation.

### Recommendation

Add Windows ACL restriction using the `windows-acl` crate or raw Win32 APIs:

```rust
#[cfg(windows)]
{
    use std::os::windows::fs::OpenOptionsExt;
    // Alternatively, use icacls or SetNamedSecurityInfo to restrict
    // to the current user only
}
```

Or as a simpler approach, use the `fs-set-permissions` crate which provides cross-platform permission setting.

---

## Finding 10: SharedSecret Not Explicitly Zeroized

**Severity:** LOW
**Location:** `src/security/crypto.rs:220`
**Category:** Cryptographic Hygiene

### Description

In `EncryptedChannel::complete()`, the `SharedSecret` from `diffie_hellman()` sits on the stack. While newer versions of `x25519-dalek` implement `Zeroize` on `SharedSecret` (meaning it IS zeroed on drop), the code does not explicitly call `.zeroize()`, and the behavior depends on the library version.

The derived key IS explicitly zeroed at line 228.

### Impact

Minimal — the SharedSecret is stack-allocated and short-lived, and modern `x25519-dalek` does implement `ZeroizeOnDrop`. This is a defense-in-depth recommendation only.

### Recommendation

Add explicit zeroization for clarity:
```rust
let mut shared = secret.diffie_hellman(peer_public);
let mut derived_key = blake3::derive_key(KDF_CONTEXT, shared.as_bytes());
shared.zeroize(); // explicit defense-in-depth
let cipher = XChaCha20Poly1305::new((&derived_key).into());
derived_key.zeroize();
```

---

## Finding 11: Temporary File Persistence on Error in `DeviceIdentity::save()`

**Severity:** LOW
**Location:** `src/security/crypto.rs:149-165`
**Category:** Cryptographic Hygiene

### Description

`save()` writes the secret key to `identity.json.tmp`, then renames to `identity.json`. If `set_permissions()` or `rename()` fails after the write, the temp file remains on disk with the full secret key. The filename is predictable.

### Impact

On failure, the secret key persists in a temp file that may have default (world-readable) permissions. Requires the `save()` error path to be triggered.

### Recommendation

Add a cleanup guard:
```rust
// Write to temp file
fs::write(&tmp_path, &json)?;

// Ensure cleanup on error
let _guard = scopeguard::guard((), |_| {
    let _ = fs::remove_file(&tmp_path);
});

#[cfg(unix)]
fs::set_permissions(&tmp_path, Permissions::from_mode(0o600))?;
fs::rename(&tmp_path, &path)?;

// Defuse the guard on success
std::mem::forget(_guard);
```

---

## Finding 12: mDNS First-Match-Wins Race Condition

**Severity:** INFO
**Location:** `src/discovery/mdns.rs:77` (`discover_by_code_hash`)
**Category:** Discovery

### Description

`discover_by_code_hash()` returns the first mDNS service whose `code_hash` TXT property matches. If an attacker registers a service with the same hash before the legitimate sender, the receiver connects to the attacker.

### Impact

On a hostile LAN, this enables the attack described in Finding 1. However, this is only a contributing factor — the root cause is Finding 1 (no PAKE binding). Fixing Finding 1 makes this race condition harmless because the attacker cannot complete the PAKE handshake.

### Recommendation

After fixing Finding 1 (PAKE binding), this becomes defense-in-depth. Optionally:
- Return all matches and let the user choose
- Verify the PAKE completes successfully before proceeding with data transfer

---

## Finding 13: Entropy Documentation Mismatch

**Severity:** INFO
**Location:** `src/net/codephrase.rs` (comment)
**Category:** Documentation

### Description

The code comment says the code phrase has "~38 bits" of entropy. The actual calculation:
- Numeric prefix: 1000-9999 = 9000 possibilities → log2(9000) = 13.14 bits
- Three words from 256: 256^3 = 16,777,216 → log2(16,777,216) = 24 bits
- Total: 13.14 + 24 = **37.14 bits**

### Recommendation

Fix the comment to say "~37 bits" instead of "~38 bits".

---

## Prioritized Remediation Plan

### Immediate (before next release)

1. **Finding 2 (OOM)**: Switch to streaming I/O for P2P transfers — highest impact, most likely to be hit by normal users
2. **Finding 6 (Sender timeouts)**: Add `tokio::time::timeout` wrappers — simple fix, prevents hangs

### Short-term (next 1-2 releases)

3. **Finding 1 (No PAKE)**: Integrate SPAKE2 or CPace for code-phrase authentication — most important security fix, but requires protocol version bump
4. **Finding 3 (Auto-trust)**: Add interactive confirmation for first-time TOFU — requires UX design decision
5. **Finding 5 (TOCTOU/symlink)**: Use `OpenOptions::create_new(true)` — straightforward fix
6. **Finding 4 (Trust store corruption)**: Return error instead of silent recovery — simple behavioral change

### When convenient

7. **Finding 7 (Windows reserved names)**: Add to `sanitize_filename()`
8. **Finding 8 (Zeroization gaps)**: Use `Zeroizing<String>` wrappers
9. **Finding 9 (Windows ACL)**: Add Windows permission restriction
10. **Finding 10 (SharedSecret)**: Add explicit `.zeroize()` call
11. **Finding 11 (Temp file)**: Add cleanup guard
12. **Finding 13 (Docs)**: Fix entropy comment
